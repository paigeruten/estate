<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0089)redhanded.hobix.com/inspect/blockAndLambda.html -->
<HTML xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><HEAD><META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--<BASE href="http://redhanded.hobix.com.wstub.archive.org/inspect/blockAndLambda.html">--><BASE href=".">


<TITLE>RedHanded » Block and Lambda</TITLE>
<LINK rel="shortcut icon" href="../favicon.ico" type="image/vnd.microsoft.icon" />
<LINK rel="icon" href="../favicon.ico" type="image/vnd.microsoft.icon" />
<META http-equiv="Pragma" content="no-cache">
<META http-equiv="Expires" content="-1">




<STYLE type="text/css">
 @import "../site.css"; 
</STYLE>
</HEAD><BODY>

<DIV id="page">

<DIV id="hoodwinkd">
  <A href="http://hoodwinkd.hobix.com/"><SPAN>hoodwink.d enhanced</SPAN></A>

</DIV>
<DIV id="buttons">
<DL class="tab">
  <DT><A title="Syndicate this Site" href="index.xml">RSS</A></DT>
  <DD><A title="Syndicate this Site" href="index.xml">2.0</A></DD>
</DL>
<DL class="tab xhtml">
  <DT><A title="Validate this Site" href="http://validator.w3.org/check?uri=http://redhanded.hobix.com/">XHTML</A></DT>
  <DD><A title="Validate this Site" href="http://validator.w3.org/check?uri=http://redhanded.hobix.com/">1.0</A></DD>
</DL>
</DIV>
<H1 class="title"><A href="../"><IMG src="../images/redhanded.gif" alt="RedHanded"></A></H1>
<DIV id="banner">
  <DIV class="tagline">sneaking Ruby through the system</DIV>
  <DIV class="nav"><A href="../5.gets/">5.gets</A> | <A href="../bits/">bits</A> | 
    <A href="../inspect/">inspect</A> | <A href="../cult/">the cult</A> | <A href="../-h/">-h</A></DIV>
</DIV>


<DIV id="content">
<DIV id="sidebar">
<P>New to RedHanded? <A href="../-h/pardonAndWelcome.html">About our sections.</A></P>

<DIV class="sidebarBox">
<H2 class="sidebarTitle">Archive</H2>
<UL>

    <LI><A href="../2004/12/">December 2004</A></LI>

    <LI><A href="../2005/01/">January 2005</A></LI>

    <LI><A href="../2005/02/">February 2005</A></LI>

    <LI><A href="../2005/03/">March 2005</A></LI>

    <LI><A href="../2005/04/">April 2005</A></LI>

    <LI><A href="../2005/05/">May 2005</A></LI>

    <LI><A href="../2005/06/">June 2005</A></LI>

    <LI><A href="../2005/07/">July 2005</A></LI>

    <LI><A href="../2005/08/">August 2005</A></LI>

    <LI><A href="../2005/09/">September 2005</A></LI>

    <LI><A href="../2005/10/">October 2005</A></LI>

    <LI><A href="../2005/11/">November 2005</A></LI>

    <LI><A href="../2005/12/">December 2005</A></LI>

    <LI><A href="../2006/01/">January 2006</A></LI>

    <LI><A href="../2006/02/">February 2006</A></LI>

    <LI><A href="../2006/03/">March 2006</A></LI>

    <LI><A href="../2006/04/">April 2006</A></LI>

    <LI><A href="../2006/05/">May 2006</A></LI>

    <LI><A href="../2006/06/">June 2006</A></LI>

    <LI><A href="../2006/07/">July 2006</A></LI>

    <LI><A href="../2006/08/">August 2006</A></LI>

    <LI><A href="../2006/09/">September 2006</A></LI>

    <LI><A href="../2006/10/">October 2006</A></LI>

    <LI><A href="../2006/11/">November 2006</A></LI>

    <LI><A href="../2006/12/">December 2006</A></LI>

    <LI><A href="../2007/01/">January 2007</A></LI>

    <LI><A href="../2007/02/">February 2007</A></LI>

    <LI><A href="../2007/03/">March 2007</A></LI>

    <LI><A href="../2007/04/">April 2007</A></LI>

    <LI><A href="../2007/05/">May 2007</A></LI>

</UL>
</DIV>

<P><A href="http://www.pragmaticprogrammer.com/titles/ruby/index.html"><IMG src="../images/prag-ruby-book.jpg" alt="PickAxe II"></A><BR>
<A href="http://www.pragmaticprogrammer.com/titles/ruby/index.html">Get your copy of <I>Programming Ruby</I>!</A></P>

 <DIV class="sidebarBox">
        <H2 class="sidebarTitle">Links</H2>
        <A href="http://technorati.com/tags/ruby">@technorati</A><BR>
<A href="http://del.icio.us/tag/ruby">@del.icio.us</A><BR>
<A href="http://www.flickr.com/photos/tags/ruby">@flickr</A><BR>
<A href="http://www.artima.com/articles/index.jsp?topic=ruby">@artima</A><BR>
<A href="http://blog.caboo.se/">@caboo</A><BR>
<A href="http://www.oreillynet.com/ruby">@oreilly</A><BR>
<A href="http://ruby-lang.org/">ruby</A><BR>
<A href="http://ruby-doc.org/">-&gt; docs</A><BR>
<A href="http://rubyforge.org/">-&gt; wares</A><BR>
<A href="http://rubygarden.org/ruby/">-&gt; wiki</A><BR>
<A href="http://www.sitepoint.com/forums/forumdisplay.php?f=227">-&gt; forum</A><BR>
<A href="http://www.rubyquiz.com/">-&gt; quizzes</A><BR>
<A href="http://planetruby.0x42.net/">-&gt; planet</A><BR>
<A href="http://meme.b9.com/cdates.html?channel=ruby-lang">-&gt; irc</A><BR>
<A href="http://www.rubyweeklynews.org/">rubyweeklynews</A><BR>
<A href="http://weblog.rubyonrails.com/">rails</A><BR>
<A href="http://wiki.rubyonrails.org/">-&gt; wiki</A><BR>
<A href="http://www.planetrubyonrails.org/">-&gt; planet</A><BR>
<A href="http://thesaq.com/rubyonrails/">-&gt; irc</A><BR>
<A href="http://anarchaia.org/">%anarchaia</A><BR>
<A href="http://project.ioni.st/">%projectionist</A><BR>
<A href="http://pugs.blogs.com/">~audreyt</A><BR>
<A href="http://dablog.rubypal.com/">~black</A><BR>
<A href="http://www.jamesbritt.com/">~britt</A><BR>
<A href="http://www.jamisbuck.org/jamis/">~buck</A><BR>
<A href="http://tomcopeland.blogs.com/juniordeveloper/">~copeland</A><BR>
<A href="http://eigenclass.org/">~fernandez</A><BR>
<A href="http://www.chadfowler.com/">~fowler</A><BR>
<A href="http://www.loudthinking.com/">~hansson</A><BR>
<A href="http://blog.segment7.net/">~hodel</A><BR>
<A href="http://slash7.com/">~hoy/7</A><BR>
<A href="http://fhwang.net/">~hwang</A><BR>
<A href="http://blog.leetsoft.com/">~luetke</A><BR>
<A href="http://www.worldlingo.com/wl/translate?wl_lp=JA-en&wl_glossary=gl1&wl_fl=3&wl_rurl=http%3A%2F%2Fwww.rubyist.net%2F%7Ematz%2F&wl_url=http%3A%2F%2Fwww.rubyist.net%2F%7Ematz%2F&wl_g_table=-3">~matz</A><BR>
<A href="http://moonbase.rydia.net/">~mental</A><BR>
<A href="http://techno-weenie.net/">~olson</A><BR>
<A href="http://pragprog.com/pragdave">~pragdave</A><BR>
<A href="http://www.livejournal.com/users/premshree/">~premshree</A><BR>
<A href="http://kronavita.de/chris/blog/">~neukirchen</A><BR>
<A href="http://www.robbyonrails.com/">~robby</A><BR>
<A href="http://www.rousette.org.uk/">~rousette</A><BR>
<A href="http://nubyonrails.com/">~topfunky</A><BR>
<A href="http://www.jvoorhis.com/">~voorhis</A><BR>
<A href="http://onestepback.org/">~weirich</A><BR>
<A href="http://blog.zenspider.com/">~zenspider</A><BR>
        </DIV> 
 <DIV class="sidebarBox">
        <H2 class="sidebarTitle">Syndicate</H2>
        <UL>
            <LI><A href="../index.xml">RSS 2.0</A></LI>
        </UL>
        </DIV> 
 <DIV class="sidebarBox">
        <P>Built upon <A href="http://hobix.com/">Hobix</A></P>
        </DIV> 
<IMG src="../images/redhanded-duck.gif" alt="Type the Duck">
<DIV class="email">Got a story for us? <A href="../mailto:redhanded@hobix.com">E-mail it!</A></DIV>
<DIV class="technorati"><P><A href="http://www.technorati.com/profile/whytheluckystiff">Technorati Profile</A>
<A href="http://www.technorati.com/cosmos/search.html?url=http%3A%2F%2Fredhanded.hobix.com"><BR>
<IMG src="../images/bubble_icon.gif" height="20" width="24" alt="Get Conversations about RedHanded &raquo; sneaking Ruby through the system"></A>
</P>
</DIV>

</DIV>


 <DIV id="blog">
        
<DIV class="entry">
    <H2 class="entryTitle">Block and Lambda
  <SPAN class="entryPermalink"><A href="../inspect/blockAndLambda.html" title="Permanent link to &ldquo;Block and Lambda&rdquo;">#</A></SPAN>
</H2>

<DIV class="entrySection">by <A href="http://d.hatena.ne.jp/babie/" title="Visit babie&#39;s homepage">babie</A> 
  in <A href="../inspect" title="List of entries in the &ldquo;inspect&rdquo; category">inspect</A>
</DIV>

     <DIV class="entryContent"><P>This entry is a loose summary of <A href="http://www.rubyist.net/~matz/">Matz blog</A> :
<A href="http://www.rubyist.net/~matz/20050630.html#p01">2005-06-30</A> ,
<A href="http://www.rubyist.net/~matz/20050701.html#p02">2005-07-01</A> ,
<A href="http://www.rubyist.net/~matz/20050721.html#p03">2005-07-21</A> ,
<A href="http://www.rubyist.net/~matz/20050722.html#p02">2005-07-22</A> .
And this entry is related to <A href="../inspect/ruby20BlockLocalVariable.html">Ruby 2.0 block local variable</A> and <A href="../inspect/functionCall.html">Function Call</A> .</P>


	<P>Matz has been thinking about new syntax of block paremter and lambda expression.
As it stands, we can’t use same syntax in block parameter as in method parameter.
So he has some ideas, but he is not satisfied with these ideas.</P>


We can write block parameters like this now:
<PRE>hash.each { |k,v| v ||= "none"; ... }
</PRE>
Following examples mean the same.

<P>
</P><H3>1. Anonymous function like Perl6</H3>

This syntax came from Perl6:
<PRE>for list -&gt; x { ... }
</PRE>
Perl6 has a near cultural sphere to Ruby, so he think it’s well to refer Perl6. 
But he worry whether Perl6 will be released or not and whether this syntax will be adopted in Perl6 or not.

<PRE>hash.each -&gt; (k,v="none") { ... }
</PRE>
This syntax is so-so in block because It reminds him of a substitution.

But when in lambda expression:
<PRE>proc = -&gt; (x, y) { ... }
</PRE>
Hmmm, it doesn’t look like a function.
<P></P>

<P>
</P><H3>2. Other sign</H3>
<PRE>hash.each \(k,v="none") { ... }
</PRE>
In Haskell, back-slash sign means lambda because of form likeness.
A matter is a back-slash sign displays as yen-sign by font environment.

In lambda case:
<PRE>proc = \(x, y) { ... }
</PRE>
In Ruby, it look like a parenthesis escaped.
<P></P>

<P>
</P><H3>3. Double back-slash</H3>
<PRE>hash.each \\(k,v="none") { ... }
</PRE>
It’s lack of visual hint.

<PRE>proc = \\(x, y) { ... }
</PRE>
He thinks better than one back-slash case.
He is worried by the same reason of font as one back-slash, too.

He thinks he should lays special emphasis on lambda expression,
because main dissatisfaction was an inconsistency that
a syntax of lambda’s parameters is different from syntax method’s parameter in the begining.
<P></P>

<P>
Though he will not choice below ideas probably, I introduce.
</P><H3>4. New keyword</H3>
<PRE>hash.each { using k,v="none"; ... }
</PRE>
<P></P>

<P>
</P><H3>5. Extend lambda</H3>
<PRE>hash.each(&amp;lambda(k,v="none") { ... })
</PRE>
<P></P>

<P>
He leaned toward an example like Perl6 and had done at his local repository, but he wavers yet.
He wants a good idea which fulfill below condition:
</P><UL>
<LI>It’s able to express anonymous function.</LI>
<LI>It puts in front of paraemters.</LI>
<LI>It’s good mix of sign which have not been used until now.</LI>
<LI>Many people feel comfortable (if possible).</LI>
</UL>
<P></P>

	<P>What do you think?</P></DIV> 
</DIV>
<DIV class="entryFooter"> 
    <NOBR>27 Jul 2005</NOBR> at <NOBR>15:35</NOBR>
    <NOSCRIPT></NOSCRIPT>
   | 
    56 comments
</DIV>
</DIV>
<DIV id="comments">


<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>murphy</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>27 Jul 2005</NOBR> at <NOBR>16:56</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>I mean, we all want to write</P>


	<PRE><CODE>hash.each { |k,v="none"| ... }</CODE></PRE>


	<P>don’t we? Is it really not possible to prefer the block-variable-| over the bit-or-| in parsing? Maybe there are other difficulties, but the only thing I see is that with this syntax you couldn’t write</P>


	<PRE><CODE>hash.each { | k, v = k|0 | ... }</CODE></PRE>


	<P>so bitwise-or wouldn’t be available in block variables or something. (After the =, an expression should be allowed, including method calls, class definitions and, of course, bitwise or.)</P>


	<P>But where’s the problem? If you really come across such a thing, just write</P>


	<PRE><CODE>hash.each { | k, v = (k|0) | ... }</CODE></PRE>


	<P>and the parser should be happy. You have to do this often in Ruby to make things clearer to the parser. This is also compatible to today’s syntax, doesn’t change much, and seems intuitive to me.</P>


	<P>Maybe I don’t understand the real problem – could someone please explain? (Or translate matz’ blog for me –  WHY  did I learn French in school instad of Japanese??? 9_9)</P>


	<P>Another idea, because I like keywords: extended do-end:</P>


	<PRE><CODE>hash.each with k, v="none" do ... end</CODE></PRE>


	<P>So weird things are only allowed in with … do … end.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>murphy</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>27 Jul 2005</NOBR> at <NOBR>17:09</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Oh, I just discovered that in with…do…end, the do could become optional: You could use <CODE>with</CODE> like you use <CODE>def</CODE>:</P>


<CODE><PRE>  # normal function
  def print2 k, v = 'none'
    p '%10s: %p' % [k, v]
  end

  # anonymous block
  hash.each with k, v = 'none'
    p '%10s: %p' % [k, v]
  end

  # lambda
  printer = lambda with k, v = 'none'
    p '%10s: %p' % [k, v]
  end
</PRE></CODE>

	<P>If you worry about one-liners now, just use do as you did before:</P>


<CODE><PRE>  # as one-liner
  hash.each with k, v = 'none' do p [k, v] end
</PRE></CODE>

	<P>What about leaving {...} as it is, and extending do…end to with…do…end?</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>sporkmonger</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>27 Jul 2005</NOBR> at <NOBR>17:38</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent">I have to say, I’m not particularly keen on any of the 5 options.  Like murphy said, what we all really wish we could have is:
<PRE>hash.each { |k,v="none"| ... }
</PRE>
So… my vote is for whatever it takes to get us the syntax we want in the first place.  If the only obstruction is that bitwise-or operations need to be clarified with parens, then I think that’s a small price to pay for the nicer aesthetics…</DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>sporkmonger</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>27 Jul 2005</NOBR> at <NOBR>17:41</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent">Oh, and if that weren’t bad enough, I even prefer
<PRE>hash.each { |k,v| v ||= "none"; ... }
</PRE>
over any of the other 5 options suggested.

	<P>Although admittedly, the fifth wouldn’t bother me nearly as much as the previous four.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Phil</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>27 Jul 2005</NOBR> at <NOBR>19:09</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent">I agree with murphy, we want to have:
<PRE><CODE>
hash.each { |k,v="none"| ... }
</CODE>
</PRE>

	<P>If you want to do an OR inside of the goal posts ’| |’ you need to surround it with ‘(’ and ‘)’ – I don’t see this as being a big problem.  It seems to be the least disruptive approach.</P>


	<P>If I have to pick one of the five options above, I prefer #5.  However, what would that mean for anonymous code blocks? (I’m guessing it would look like the Perl6 example, but without the ’-&gt;‘).</P>


	<P>Why is the extra arrow needed in the Perl6ish-way shown in #1?  If you get rid of the arrow wouldn’t you essentially have the same thing as #5?</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Tom</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>27 Jul 2005</NOBR> at <NOBR>19:43</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Totally agree with sporkmonger.  I’d much prefer to have the syntax we actually want, and if it’s not possible, the current way.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>JWL</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>27 Jul 2005</NOBR> at <NOBR>19:50</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>1+ for keeping the current goal post syntax.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Daniel Berger</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>27 Jul 2005</NOBR> at <NOBR>22:24</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Dear murphy,</P>


	<P>No, we don’t.  Leave it alone.  It doesn’t look any better or clearer to me.  In fact it looks worse.</P>


	<P>And, if your object doesn’t already have a default value, or the capability of having  a default value, then you’ve probably screwed up long before you reach this point.</P>


	<P>I’m not sure how Matz got it in his head that block parameters and method parameters should work the same.  They’re different, mmkay?</P>


	<P>Note to Ruby community: stop obsessing over blocks and procs.  I don’t want the syntax wrecked over some misguided notion of block/lambda/method unification.</P>


	<P>P.S. Hash.new(“none”)</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Dan</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>27 Jul 2005</NOBR> at <NOBR>22:39</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent">I’m with you guys on this syntax, it looks great to me:
<PRE><CODE>
hash.each { |k,v="none"| ... }
</CODE>
</PRE>
Is the whole problem really the ambiguity with the bit-wise or?  Seems like a lot of trouble to change a common case (blocks) to save a rare case (bit-wise or). There must be something else that matz is trying to step around…must be…

But if matz is really considering all those other ways, here are some more crazy ideas (some not-so-serious):
<PRE><CODE>
proc = &amp;lt;k,v="none"&amp;gt;  { ... } # hmmmm...won't work
proc = &amp;(k,v="none") { ... } # maybe...
proc = ~(k,v="none") { ... } # we lose bit-wise not, boo-hoo, big deal
proc = (k,v="none")  { ... } # I'm sure there's some reason we can't to this one
proc = |k,v="none"|  { ... } # Same problem as the current favorite
</CODE></PRE><CODE>
</CODE>

	<P>I’m all out.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Dan</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>27 Jul 2005</NOBR> at <NOBR>22:44</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Those &lt; and &gt; looked great in the preview…sorry everyone. Hey _why, something to look at: &lt; and &gt; in the preview don’t show up, but they do when the post is committed.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Revolutionary</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>27 Jul 2005</NOBR> at <NOBR>23:41</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>You are all tied up into being comfortable by avoiding change. Change <EM>is</EM> good. It keeps you on your toes to perform your best. I personally like the \() syntax.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>piggie</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>27 Jul 2005</NOBR> at <NOBR>23:43</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>I feel like this is trying to solve a problem that doesn’t (or barely) exist.</P>


	<P>Both of these options look and feel like Ruby:</P>


<PRE><CODE>
hash.each { |k,v| v ||= "none"; ... }
hash.each { |k,v="none"| ... }
</CODE></PRE>

	<P>The rest feel (as the parent post notes their origins) like other languages entirely.  The syntax of Ruby should to continue to adhere to  POLS .</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>babie</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>27 Jul 2005</NOBR> at <NOBR>23:50</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Hi, all!
Matz said that it’s too difficult to write a ”|” operator in present block because of parser(yacc).</P>


	<P>Hi Dan. There is samples used various characters at <A href="http://www.namikilab.tuat.ac.jp/~sasada/diary/200507.html#d1">Sasada’s diary</A> .</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>matz</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>28 Jul 2005</NOBR> at <NOBR>00:51</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>yep.  I don’t want to introduce new syntax if we could implement optional arguments in the goal posts.  I’m waiting for some super  YACC  guru.</P>


	<P>hmm, “goal posts”, I like the name.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>trans</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>28 Jul 2005</NOBR> at <NOBR>00:58</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Along the Perl6 line of thought this seems simpler:</P>


<CODE>method(x,y) { a,b="none" -&gt; ... }</CODE>

	<P>But the one that seems most intuitive to me is:</P>


<CODE>method(x,y) { (a,b="none") ... }</CODE>

	<P>But that might have some parsing problems itself, does it? Of course one could just use backslash in place of pipes.</P>


<CODE>method(x,y) { \a,b="none"\ ... }</CODE>

	<P>That should work without ambiguity. On the otherhand I find the last notation using the lambda interesting. Might we not just drop the word “lambda” and use only the &amp; to do:</P>


<CODE>method(x,y) &amp;(a,b="none"){ ... }</CODE>

	<P>2c.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Phil</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>28 Jul 2005</NOBR> at <NOBR>01:38</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Matz: Maybe it’s because it’s not a currently available feature, but  I don’t think I’ve ever needed a default-valued argument for a block.  What is the problem we’re trying to solve with the proposed changes?</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>murphy</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>28 Jul 2005</NOBR> at <NOBR>05:48</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>My knowledge of lex/yacc is very poor, but I know the problem of ambiguous symbols. A solution is, for example: Ruby scans a ”+” either as <STRONG>plus</STRONG> or as <STRONG>tUPLUS</STRONG>, depending on some lex_state.</P>


To parse | correctly, we need a stack, because a block can contain expressions with |-op, but also more blocks that contain |-ops etc. Maybe it is enough to keep track of all opened parentheses to decide about ”|”:
	<UL>
	<LI>if the last was a “{”, it is a block parameters delimiter</LI>
		<LI>if it was a “(” or none, it is bit-or.</LI>
	</UL>


	<P>So it could be solved one the lexer level.</P>


	<P>Has someone described the parsing problem in English yet? Where it lies exactly?</P>


	<P>Another idea is maybe to use the semicolon:</P>


	<PRE><CODE>array.map { |foo = 15; foo * 2 }</CODE></PRE>


	<P>But that would interfere with the new block variables section.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Mike</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>28 Jul 2005</NOBR> at <NOBR>06:02</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>I’m not much of a  YACC /LEX guru. But doing the nice syntax one would require infinite lookahead no? I don’t see how that could be done with  YACC . Isn’t it possible to switch to a more sophisticated parser with backtracking, infinite lookahead or something like that? I think (not sure) there are some free ones that have that and are based on  YACC .</P>


	<P>The proposed syntaxes do like kind of weird… Number four seems clean to me but loses the brevity Ruby has on this right now.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Sigsegv</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>28 Jul 2005</NOBR> at <NOBR>06:06</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Here at the <A href="http://www.tu-berlin.de/">TU-Berlin</A>  we have <A href="http://uebb.cs.tu-berlin.de/opal">opal</A> , and they define lambdas with \\x,y. or \\_ .</P>


	<P>Jut my 0.2 Cent</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Matt</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>28 Jul 2005</NOBR> at <NOBR>06:50</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>I don’t like the proposed syntaxes either.  I guess adding a lot of syntax to the language for a feature that I’m not sure I’ll even use doesn’t seem like a good tradeoff that way.  That way lies madness.  And perl.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>sporkmonger</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>28 Jul 2005</NOBR> at <NOBR>06:54</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>phil: I know, I was wondering that myself.  To be honest, even if the current syntax were maintained, I can’t think of any good reason I would want or need to use optional parameters in a block.  So I have to ask, is the point of all of this just to blur the line between blocks and methods for the sake of it, or do we have some more practical purpose for all of this?</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>trans</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>28 Jul 2005</NOBR> at <NOBR>07:10</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>I just noticed something else that’s nice about this notation:</P>


<CODE>method(x,y) &amp;(a,b="none"){ ... }</CODE>

	<P>It slips right into the parameter list:</P>


<CODE>method(x,y,&amp;(a,b="none"){ ... })</CODE>

	<P>That’s a plus.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>trans</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>28 Jul 2005</NOBR> at <NOBR>07:16</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>On the otherhand, why not deprecate the | operator in favor of ^? Double-bar || could remain b/c it would be unambigious.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Moe</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>28 Jul 2005</NOBR> at <NOBR>07:29</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><BLOCKQUOTE>
	<P>On the otherhand, why not deprecate the | operator in favor of ^? Double-bar || could remain b/c it would be unambigious.</P>

</BLOCKQUOTE>




	<P>And deprecate <CODE>^</CODE> in favor of what then?</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>jvoorhis</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>28 Jul 2005</NOBR> at <NOBR>08:00</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>If anyone actually reads this far down, I advocate the conservative approach of leaving well enough alone unless we get <CODE>|k,v='none'|</CODE>.</P>


	<P>I’d rather write <CODE>v ||= 'none'</CODE> on the next line and keep my backwards compatibility than rewrite my existing code so I can have a <EM>different</EM> syntax for functionality that I rarely use (or have seen others use for that matter).</P>


	<P>Wouldn’t you like to be able to <EM>use</EM> Ruby 2.0 right away? :)</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>cmo</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>28 Jul 2005</NOBR> at <NOBR>09:13</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Here is a syntax which is a mix between substitution syntax and the one in point 5:</P>


<CODE>

list.each((x,y)-&gt;{...})

and 

proc = ((x,y)-&gt;{...})
</CODE>

	<P>’# Can double parns signify a block or/and lambda without parsing problems?</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>hgs</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>28 Jul 2005</NOBR> at <NOBR>09:29</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>There is <A href="http://www.rubycentral.com/faq/rubyfaq-6.html#ss6.6">information in the  FAQ </A> about weird results with <CODE>puts</CODE> caused by the parser which baffles new users.  We now have this.  There have been other issues (I forget what) which have been constrained by the parser.  I would suggest that serious thought should be given to re-working the parser before re-working the syntax.   YACC  is fairly old technology now, there are  GLR  parsers, and probably other things I am unaware of. [Disclaimer, my ability to write parsers has proved particularly weak, so I claim no expertise]. Surely <A href="http://www.rubycentral.com/faq/ruby_newsgroup_faq.txt">There’s A Better Way To Do It</A>, isn’t there?</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>vontrapp</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>28 Jul 2005</NOBR> at <NOBR>09:51</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>For what it’s worth, I like the current syntax <B>because</B> it’s clear where those variables go. They are inside the block, which makes sense to me. If we really have to change it. I guess I would prever the <CODE>(x,y)-&gt;{...}</CODE> because it gives the notion of x and y injecting into the block. <CODE>(x,y){...}</CODE> in all it’s forms just doesn’t flow to me, it’s a lot more effort for <B>me</B> to parse it. Does anyone else feel the same?</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Dave</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>28 Jul 2005</NOBR> at <NOBR>11:01</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>I like murphy’s with…do…end idea, but I think I’m the only one.  Of all the options, it’s the only one that makes the sense at-a-glance about what’s going on.</P>


	<P>Then again, I never really liked the goal posts – they always strike me as a quirky hack.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>trans</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>28 Jul 2005</NOBR> at <NOBR>11:25</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><BLOCKQUOTE>
		<P>And deprecate <CODE>^</CODE> in favor of what then?</P>
	</BLOCKQUOTE>


	<P>Well, given how rare it is, <CODE>#xor</CODE> would probably do, but never fear <CODE>^^</CODE> is here.</P>


	<P>(P.S. Ironically I was looking a MathWorld site and ^ is more akin to symbol used for  AND . Go figure!)</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Nyarly</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>28 Jul 2005</NOBR> at <NOBR>11:53</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>For what it’s worth, I agree with you, Dave.  I like with (arg=0) do … end.</P>


Especially because it can be used in semantic analogy to def.  I am a little curious about how it would work in terms of zero argument blocks.
<PRE>array.each with do 
  count+=1
end
</PRE>
looks a little weird.

	<P>On the other hand, I’ve come to love the goal posts as a quirk of Ruby.  I suspect that, the same way that, by convention, one line procs are {} and multi lines are do…end, mutlilines will become with () end, and oneliners will become {|| }.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>MenTaLguY</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>28 Jul 2005</NOBR> at <NOBR>12:34</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>with … do is my favorite next to goalposts.  I imagine with zero-argument blocks you’d omit the with.  No arguments to do it <EM>with</EM> after all.</P>


	<P>with … do really is the best of the alternatives; I hope matz is following the thread…</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Sam</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>28 Jul 2005</NOBR> at <NOBR>16:22</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>The haskell lambda example given is for a uncurried (tupled) anonymous function. It is not required that the anonymous function be written that way.</P>


	<P>\x y → x + y</P>


	<P>which is just shorthand for</P>


	<P>\x → \y → x + y</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>caleb</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>28 Jul 2005</NOBR> at <NOBR>23:36</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>It didn’t take me too long to extend RubyLexer to get default parameters in blocks working the in murphy’s preferred way. I don’t really speak yacc, and the algorithm isn’t a simple one to implement by itself, since the right-hand-side of the default parameter needs to be able to be (almost) any ruby expression.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>caleb</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>28 Jul 2005</NOBR> at <NOBR>23:44</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Matz, what are the chances of using RubyLexer in the ruby interpreter? ;)</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>ko1</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>29 Jul 2005</NOBR> at <NOBR>05:00</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>some examples are here: http://pub.cozmixng.org/~the-rwiki/rw-cgi.rb?cmd=view;name=Ruby2.0BlockParameterNotation</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>maldoror</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>30 Jul 2005</NOBR> at <NOBR>18:23</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>I like the pascaliness in  with … do
but that’s just the little Wirth in me</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>flori</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>31 Jul 2005</NOBR> at <NOBR>06:01</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>I really like Trans’ first example:</P>


	<P>f = { x, y → x + 2 * y }</P>


	<P>f[1, 2] # =&gt; 5</P>


	<P>g = { → :constant }</P>


	<P>g[] # =&gt; :constant</P>


	<P>h = { → }</P>


	<P>h[] # =&gt; nil</P>


	<P>It looks almost like the mathematical way to define functions. It should be easy to parse this with  YACC , or do I miss something?</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>William</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>31 Jul 2005</NOBR> at <NOBR>12:56</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>I too see limited usage of default variables in block arguments, but if we  MUST  have them, I agree with Murphy: rewrite the parser until something like</P>


<CODE>hash.each { |k, v = (k|0)| ... }</CODE> 

	<P>is possible.</P>


	<P>All of the proposed syntax changes are ugly and involve too much typing for something that  SHOULD  be as simple as possible. Ruby has got this right and no other language does—let’s not break that now.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Sam</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>03 Aug 2005</NOBR> at <NOBR>01:25</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Can we have our lambdas with curry… please???</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Brian</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>03 Aug 2005</NOBR> at <NOBR>11:26</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>What stands in the way of</P>


	<PRE><CODE>hash.each { (k, v = 12) ... }</CODE></PRE>


	<P>which is nicely similar to</P>


	<PRE><CODE>def name(k, v=12)
end</CODE></PRE>


with 
	<UL>
	<LI>def → {</LI>
		<LI>name → theres none, its anonymous</LI>
		<LI>(k, v=12) → (k, v=12)</LI>
		<LI>end → }</LI>
	</UL>


	<P>PS: I’m, sure I missed something</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>JasonWatkins</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>04 Aug 2005</NOBR> at <NOBR>11:50</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>I like murphy’s suggestions as well, including the with keyword. I don’t think I’ve done enough ruby to know how useful default params in blocks would be… but it seems like a reasonable compramise to keep the goalposts as is, and force those who need defaults to use the with form.</P>


	<P>I don’t like the way any of the 5 proposals look. Assuming it’s a rarely used syntax, like the generally delimited input, I don’t see how it would hurt anything to use the double slash though.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Jeff</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>04 Aug 2005</NOBR> at <NOBR>11:58</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>I like the with [do] end syntax … but I think this would be a good place for list comprehensions like python</P>


	<P>why not just turn #each into</P>


<PRE>for k,v=None in hash
  # do stuff
end
</PRE>

	<P>or</P>


<PRE>for key in hash.keys
  # do stuff
end
</PRE>

	<P>then they add some cool optional conditionals … very cool stuff.</P>


<PRE>for k,v in hash if k != "blah" 
  # do stuff.
end
</PRE></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Jo</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>05 Aug 2005</NOBR> at <NOBR>03:19</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>@Matz:  A YACC  alternative is www.antlr.org &amp; xpa.sf.net.  BTW , the best compiler technology available is  OCAML ; see www.ocaml-tutorial.org and for an example mtasc.org. The Perl 6 VM is based on Haskell, cf. www.pugscode.org.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>wolverian</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>05 Aug 2005</NOBR> at <NOBR>12:22</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>@Jo: Pugs is “only” a bootstrap compiler for Perl 6. The final compiler will be written in either Perl 6 or a subset of it aimed specifically at compiler production. That’s the plan, anyway.</P>


	<P>What does that have to do with OCaml, anyway? :)</P>


	<P>I’ve always hated the goalposts in Ruby, in addition to the complete lack of English similarity.</P>


<PRE>foo.each do |elem| ... end</PRE>

	<P>That simply does not read naturally to an English reader (which I’m not, incidentally, but close enough to feel the syntax odd.)</P>


<PRE>for foo -&gt; elem do ... end</PRE>

	<P>That’s my preferred syntax, but it really is rather unrubyish, I guess. But then again, I don’t like the Ruby idiom of .each in the first place.</P>


	<P>I prefer <CODE>list -&gt; elem</CODE> over <CODE>elem in list</CODE> because I consider the list to be more important than the iterator element.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Jo</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>05 Aug 2005</NOBR> at <NOBR>14:21</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>@wolverian: Pugs 6.2.8 ff. is intended to become a full-fledged Perl6 compiler. I’ve even read that Pugs might one day even be capable of producing Perl6 code. – Haskell is a very good compiler language . . . and so is www.ocaml.org. Would be cool to know if Autrijus also took a deeper look into the alternative!</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>wolverian</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>06 Aug 2005</NOBR> at <NOBR>00:55</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>@Jo: Yes, but it’s not meant to become the reference implementation. Sorry, this is OT discussion, really. :)</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>sam12</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>06 Aug 2005</NOBR> at <NOBR>08:27</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>For those interested in more information on Perl6 issues &amp; discussions see: www.sidhe.org/~dan/blog/ (Dan Sugalski, developer of Parrot) and the Periodic Table of the Perl6 Operators over at www.ozonehouse.com/mark/blog/. To compare code in terms of readability you also might want to ckeck out such sites as pleac.sf.not or www.talkaboutprogramming.com. In Perl5, e.g., you have the foreach-loop pattern that first names the iterator and then the list: foreach $variable (@array) ...</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>wolverian</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>06 Aug 2005</NOBR> at <NOBR>10:31</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>@sam12: Dan Sugalski is not a Parrot (lead or otherwise) developer anymore, he gave off the hat to Chip Salzenberg. He was never a Perl6 developer, although certainly Parrot and Perl6 are related.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>murphy</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>07 Aug 2005</NOBR> at <NOBR>15:39</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>But what about the <EM>block</EM> problem?</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Pieter</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>09 Aug 2005</NOBR> at <NOBR>02:53</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>I dunno – while my experience with Ruby is very (very!) limited, and while the “goalpost” notation still feels wierd, both of murphy’s suggestions seem to feel consistant.  Personally, I like the verbosity of with..[do]..end, but I can see the reason in the “extended goalpost” notation.  The other options just felt wrong.  That’s all I can say.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>murphy</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>09 Aug 2005</NOBR> at <NOBR>08:25</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Maybe it’s better to talk here: <A href="http://rubyurl.com/M7Pgv">comp.lang.ruby</A></P>


	<P>By the way, the whole thing is just for lambdas; matz won’t change normal block syntax.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>sam12</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>10 Aug 2005</NOBR> at <NOBR>04:10</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>An improved parser may do the trick: allow more code syntax options, protect against ambiguities, ... (see above). However, I’m wondering if a preprocessor could do the trick as well (cf. man perlfilter; for a Ruby preprocessor example see rubystuff.org).
@wolverian: perl6.concat(parrot); parrot.concat(perl6), ... or just understand Perl6 as an umbrella word for both Perl6- and Parrot-related issues!</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>wolverian</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>12 Aug 2005</NOBR> at <NOBR>23:11</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>@sam12: You mean “perl6” ~ “parrot”, right? ;) Anyway, thanks for the clarification. Being involved in the process makes me differentiate between these things more than the someone outside, I guess.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Jo</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>05 Sep 2005</NOBR> at <NOBR>08:10</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>A full C parser written in OCaml that modifies the lexer while parsing is the C Intermediate Language (manju.cs.berkeley.edu/cil/). Would be cool to have such a thing for Ruby as well (in addition see rockit.sf.net and merd.sf.net for Ruby; and the OCaml preprocessor by martin.jambom.free.fr/ocaml.html).</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>tz</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>05 Sep 2005</NOBR> at <NOBR>11:09</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Jo, you’ve overlooked this one: nekovm.org</P></DIV></DIV>
</DIV>


  <DIV class="entry">
    <P><SMALL>Comments are closed for this entry.</SMALL></P>
  



        </DIV> 

</DIV>



</DIV>





</DIV></BODY></HTML>