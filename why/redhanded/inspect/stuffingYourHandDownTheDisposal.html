<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0106)redhanded.hobix.com/inspect/stuffingYourHandDownTheDisposal.html -->
<HTML xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><HEAD><META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--<BASE href="http://redhanded.hobix.com.wstub.archive.org/inspect/stuffingYourHandDownTheDisposal.html">--><BASE href=".">


<TITLE>RedHanded » Stuffing Your Hand Down the Disposal</TITLE>
<LINK rel="shortcut icon" href="../favicon.ico" type="image/vnd.microsoft.icon" />
<LINK rel="icon" href="../favicon.ico" type="image/vnd.microsoft.icon" />
<META http-equiv="Pragma" content="no-cache">
<META http-equiv="Expires" content="-1">




<STYLE type="text/css">
 @import "../site.css"; 
</STYLE>
</HEAD><BODY>

<DIV id="page">

<DIV id="hoodwinkd">
  <A href="http://hoodwinkd.hobix.com/"><SPAN>hoodwink.d enhanced</SPAN></A>

</DIV>
<DIV id="buttons">
<DL class="tab">
  <DT><A title="Syndicate this Site" href="index.xml">RSS</A></DT>
  <DD><A title="Syndicate this Site" href="index.xml">2.0</A></DD>
</DL>
<DL class="tab xhtml">
  <DT><A title="Validate this Site" href="http://validator.w3.org/check?uri=http://redhanded.hobix.com/">XHTML</A></DT>
  <DD><A title="Validate this Site" href="http://validator.w3.org/check?uri=http://redhanded.hobix.com/">1.0</A></DD>
</DL>
</DIV>
<H1 class="title"><A href="../"><IMG src="../images/redhanded.gif" alt="RedHanded"></A></H1>
<DIV id="banner">
  <DIV class="tagline">sneaking Ruby through the system</DIV>
  <DIV class="nav"><A href="../5.gets/">5.gets</A> | <A href="../bits/">bits</A> | 
    <A href="../inspect/">inspect</A> | <A href="../cult/">the cult</A> | <A href="../-h/">-h</A></DIV>
</DIV>


<DIV id="content">
<DIV id="sidebar">
<P>New to RedHanded? <A href="../-h/pardonAndWelcome.html">About our sections.</A></P>

<DIV class="sidebarBox">
<H2 class="sidebarTitle">Archive</H2>
<UL>

    <LI><A href="../2004/12/">December 2004</A></LI>

    <LI><A href="../2005/01/">January 2005</A></LI>

    <LI><A href="../2005/02/">February 2005</A></LI>

    <LI><A href="../2005/03/">March 2005</A></LI>

    <LI><A href="../2005/04/">April 2005</A></LI>

    <LI><A href="../2005/05/">May 2005</A></LI>

    <LI><A href="../2005/06/">June 2005</A></LI>

    <LI><A href="../2005/07/">July 2005</A></LI>

    <LI><A href="../2005/08/">August 2005</A></LI>

    <LI><A href="../2005/09/">September 2005</A></LI>

    <LI><A href="../2005/10/">October 2005</A></LI>

    <LI><A href="../2005/11/">November 2005</A></LI>

    <LI><A href="../2005/12/">December 2005</A></LI>

    <LI><A href="../2006/01/">January 2006</A></LI>

    <LI><A href="../2006/02/">February 2006</A></LI>

    <LI><A href="../2006/03/">March 2006</A></LI>

    <LI><A href="../2006/04/">April 2006</A></LI>

    <LI><A href="../2006/05/">May 2006</A></LI>

    <LI><A href="../2006/06/">June 2006</A></LI>

    <LI><A href="../2006/07/">July 2006</A></LI>

    <LI><A href="../2006/08/">August 2006</A></LI>

    <LI><A href="../2006/09/">September 2006</A></LI>

    <LI><A href="../2006/10/">October 2006</A></LI>

    <LI><A href="../2006/11/">November 2006</A></LI>

    <LI><A href="../2006/12/">December 2006</A></LI>

    <LI><A href="../2007/01/">January 2007</A></LI>

    <LI><A href="../2007/02/">February 2007</A></LI>

    <LI><A href="../2007/03/">March 2007</A></LI>

    <LI><A href="../2007/04/">April 2007</A></LI>

    <LI><A href="../2007/05/">May 2007</A></LI>

</UL>
</DIV>

<P><A href="http://www.pragmaticprogrammer.com/titles/ruby/index.html"><IMG src="../images/prag-ruby-book.jpg" alt="PickAxe II"></A><BR>
<A href="http://www.pragmaticprogrammer.com/titles/ruby/index.html">Get your copy of <I>Programming Ruby</I>!</A></P>

 <DIV class="sidebarBox">
        <H2 class="sidebarTitle">Links</H2>
        <A href="http://technorati.com/tags/ruby">@technorati</A><BR>
<A href="http://del.icio.us/tag/ruby">@del.icio.us</A><BR>
<A href="http://www.flickr.com/photos/tags/ruby">@flickr</A><BR>
<A href="http://www.artima.com/articles/index.jsp?topic=ruby">@artima</A><BR>
<A href="http://blog.caboo.se/">@caboo</A><BR>
<A href="http://www.oreillynet.com/ruby">@oreilly</A><BR>
<A href="http://ruby-lang.org/">ruby</A><BR>
<A href="http://ruby-doc.org/">-&gt; docs</A><BR>
<A href="http://rubyforge.org/">-&gt; wares</A><BR>
<A href="http://rubygarden.org/ruby/">-&gt; wiki</A><BR>
<A href="http://www.sitepoint.com/forums/forumdisplay.php?f=227">-&gt; forum</A><BR>
<A href="http://www.rubyquiz.com/">-&gt; quizzes</A><BR>
<A href="http://planetruby.0x42.net/">-&gt; planet</A><BR>
<A href="http://meme.b9.com/cdates.html?channel=ruby-lang">-&gt; irc</A><BR>
<A href="http://www.rubyweeklynews.org/">rubyweeklynews</A><BR>
<A href="http://weblog.rubyonrails.com/">rails</A><BR>
<A href="http://wiki.rubyonrails.org/">-&gt; wiki</A><BR>
<A href="http://www.planetrubyonrails.org/">-&gt; planet</A><BR>
<A href="http://thesaq.com/rubyonrails/">-&gt; irc</A><BR>
<A href="http://anarchaia.org/">%anarchaia</A><BR>
<A href="http://project.ioni.st/">%projectionist</A><BR>
<A href="http://pugs.blogs.com/">~audreyt</A><BR>
<A href="http://dablog.rubypal.com/">~black</A><BR>
<A href="http://www.jamesbritt.com/">~britt</A><BR>
<A href="http://www.jamisbuck.org/jamis/">~buck</A><BR>
<A href="http://tomcopeland.blogs.com/juniordeveloper/">~copeland</A><BR>
<A href="http://eigenclass.org/">~fernandez</A><BR>
<A href="http://www.chadfowler.com/">~fowler</A><BR>
<A href="http://www.loudthinking.com/">~hansson</A><BR>
<A href="http://blog.segment7.net/">~hodel</A><BR>
<A href="http://slash7.com/">~hoy/7</A><BR>
<A href="http://fhwang.net/">~hwang</A><BR>
<A href="http://blog.leetsoft.com/">~luetke</A><BR>
<A href="http://www.worldlingo.com/wl/translate?wl_lp=JA-en&wl_glossary=gl1&wl_fl=3&wl_rurl=http%3A%2F%2Fwww.rubyist.net%2F%7Ematz%2F&wl_url=http%3A%2F%2Fwww.rubyist.net%2F%7Ematz%2F&wl_g_table=-3">~matz</A><BR>
<A href="http://moonbase.rydia.net/">~mental</A><BR>
<A href="http://techno-weenie.net/">~olson</A><BR>
<A href="http://pragprog.com/pragdave">~pragdave</A><BR>
<A href="http://www.livejournal.com/users/premshree/">~premshree</A><BR>
<A href="http://kronavita.de/chris/blog/">~neukirchen</A><BR>
<A href="http://www.robbyonrails.com/">~robby</A><BR>
<A href="http://www.rousette.org.uk/">~rousette</A><BR>
<A href="http://nubyonrails.com/">~topfunky</A><BR>
<A href="http://www.jvoorhis.com/">~voorhis</A><BR>
<A href="http://onestepback.org/">~weirich</A><BR>
<A href="http://blog.zenspider.com/">~zenspider</A><BR>
        </DIV> 
 <DIV class="sidebarBox">
        <H2 class="sidebarTitle">Syndicate</H2>
        <UL>
            <LI><A href="../index.xml">RSS 2.0</A></LI>
        </UL>
        </DIV> 
 <DIV class="sidebarBox">
        <P>Built upon <A href="http://hobix.com/">Hobix</A></P>
        </DIV> 
<IMG src="../images/redhanded-duck.gif" alt="Type the Duck">
<DIV class="email">Got a story for us? <A href="../mailto:redhanded@hobix.com">E-mail it!</A></DIV>
<DIV class="technorati"><P><A href="http://www.technorati.com/profile/whytheluckystiff">Technorati Profile</A>
<A href="http://www.technorati.com/cosmos/search.html?url=http%3A%2F%2Fredhanded.hobix.com"><BR>
<IMG src="../images/bubble_icon.gif" height="20" width="24" alt="Get Conversations about RedHanded &raquo; sneaking Ruby through the system"></A>
</P>
</DIV>

</DIV>


 <DIV id="blog">
        
<DIV class="entry">
    <H2 class="entryTitle">Stuffing Your Hand Down the Disposal
  <SPAN class="entryPermalink"><A href="../inspect/stuffingYourHandDownTheDisposal.html" title="Permanent link to &ldquo;Stuffing Your Hand Down the Disposal&rdquo;">#</A></SPAN>
</H2>

<DIV class="entrySection">by <A href="http://whytheluckystiff.net/" title="Visit why&#39;s homepage">why</A> 
  in <A href="../inspect" title="List of entries in the &ldquo;inspect&rdquo; category">inspect</A>
</DIV>

     <DIV class="entryContent"><P>Since we have our heads tilted in the direction of <A href="http://del.icio.us/tag/ruby+gc">ruby+gc</A>, Eustáquio “TaQ” Rangel posted concerns about Ruby’s garbage collector yesterday on Ruby-Talk which led to an interesting bit of code from Yohanes Santoso for watching the garbage collector slurp up variables gone from scope.</P>


	<P>Specifically this code which creates a bunch of objects and watches them fade from existence.</P>


<PRE> class CustObj
   attr_accessor :val, :next
   def initialize(v,n=nil)
     @val        = v
     @next       = n
   end
   def to_s
     "Object #{@val} (#{self.object_id}) points to " \
     "#{@next.nil? ? 'nothing' : @next.val} " \
     "(#{@next.nil? ? '':@next.object_id})" 
   end
 end

 def list
   print "Listing all CustObj's with ObjectSpace\n" 
   print "#{ObjectSpace.each_object(CustObj) {|v| puts v}}" \
         " objects found\n\n" 
 end

 begin        # start a new scope so we can exit it later
   c1 = CustObj.new(1,CustObj.new(2,CustObj.new(3)))
   c4 = CustObj.new(4,CustObj.new(5))
   c6 = CustObj.new(6)
   c1.next.next.next = c1        # comment this and check again
   puts "### Initial" 
   list

   c1 = nil
   c4.next = nil

   GC.start

   puts "### After gc, but still within declaring scope" 
   list
 end

 puts "### Exited the scope" 
 list

 GC.start                        # here I want c1 disappears

 puts "### After gc, outside of declaring scope" 
 list
</PRE>

	<P>Here’s a great script for understanding how the collector works and how important scope is to the collector.  The important variable to watch is Object #1.  Notice how, even after its set to <CODE>nil</CODE>, its object is still around because it is referenced by Object #3.  And it’s still around after the scope is closed. But once the scope is closed and the GC is manually run, Object #1 disappears.</P>


	<P>The point of this illustration isn’t to encourage you to run GC manually.  It’s to encourage you to use scope to control the variables you’re hanging on to.  Even if it means enclosing some stuff in <CODE>begin..end</CODE>.</P>


	<P>Here’s a little watcher class, based on the above that you can use to monitor the presence of objects:</P>


<PRE> class GCWatcher
   def initialize; @objs = []; end
   def watch( obj )
     @objs &lt;&lt; [obj.object_id, obj.inspect]
     obj
   end
   def list
     puts "** objects watched by GcWatcher **" 
     @objs.each do |obj_id, obj_inspect|
       if ( ObjectSpace._id2ref( obj_id ) rescue nil )
         puts "#{ obj_inspect } is still around." 
       else
         puts "#{ obj_inspect } is collected." 
       end
     end
     puts "** #{ @objs.length } objects watched **" 
     puts
   end
 end
</PRE>

	<P>Create a <CODE>GCWatcher</CODE> object and fill it with references using the <CODE>watch</CODE> method.  The object will only keep track of object IDs, so it keeps no reference to the actual objects.  See a complete sample <A href="http://whytheluckystiff.net/ruby/gcwatcher.rb">here</A>.  (Inspired by <A href="../ruby-talk/147351">ruby-talk:147351</A>.)</P></DIV> 
</DIV>
<DIV class="entryFooter"> 
    <NOBR>07 Jul 2005</NOBR> at <NOBR>17:07</NOBR>
    <NOSCRIPT></NOSCRIPT>
   | 
    20 comments
</DIV>
</DIV>
<DIV id="comments">


<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>TaQ</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>08 Jul 2005</NOBR> at <NOBR>08:38</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Just for comparison reasons, that’s how the original code looks like:
http://redhanded.hobix.com/ruby-talk/147345</P>
	<P>Then Yohanes fixed it with the begin … end stuff. And what a difference! No more lost objects there. :-)</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>MenTaLguY</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>08 Jul 2005</NOBR> at <NOBR>14:35</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Of course, you could also write <CODE>GCWatcher</CODE> using <CODE>WeakRef</CODE>:</P>
<PRE><CODE>
require 'weakref'
class GCWatcher
  def initialize ; @objs = [] ; end
  def watch( obj )
    @objs &lt;&lt; [ WeakRef::new(obj), obj.inspect ]
    obj
  end
  def list
    puts "** objects watched by GcWatcher **" 
    @objs.each do |obj_ref, obj_inspect|
      if obj_ref.weakref_alive?
        puts "#{ obj_inspect } is still around." 
      else
        puts "#{ obj_inspect } is collected." 
      end
    end
    puts "** #{ @objs.length } objects watched **" 
    puts
  end
end
</CODE></PRE>
	<P> IIRC  internally <CODE>WeakRef</CODE> just does the <CODE>ObjectSpace._id2ref</CODE> dance too, but I think it’s slightly more readable.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>twifkak</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>10 Jul 2005</NOBR> at <NOBR>08:49</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Am confused… I thought <CODE>begin...end</CODE> and the like had the exact same scope as their containers (i.e. the <CODE>c1</CODE> variable is available outside). What’s this craziness with the GC and the it not being so?</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>twifkak</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>10 Jul 2005</NOBR> at <NOBR>08:52</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>That is to say, I understand the circular reference and conservative GC bit. I just don’t understand why escaping what seems to me to be a non-existent scope should nudge the GC into cleaning it up.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>MenTaLguY</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>10 Jul 2005</NOBR> at <NOBR>16:44</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Actually, the OP was abusing the definition of “conservative GC”. Ruby’s GC would be properly termed precise, rather than conservative.</P>
	<P>Conservative collectors look at raw memory and assume that any data that might be a pointer is one.  A precise collector is one, like Ruby’s, that <EM>knows</EM> the structure of its objects and where the references to other objects lie.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Matt</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>10 Jul 2005</NOBR> at <NOBR>18:29</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Yeah, I second the confusion.  begin..end doesn’t seem to start a new scope, so what’s going on?  Also, I’ve always heard Ruby’s collector referred to as conservative… I think even the pickaxe book says that.  So what’s going on here?</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>why</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>10 Jul 2005</NOBR> at <NOBR>18:54</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Variables declared inside a <CODE>begin..end</CODE> or inside a block are block local, they perish with the close of the block.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>George</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>11 Jul 2005</NOBR> at <NOBR>06:03</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>I think the GC is precise when it comes to object to object references, but conservative
 when it comes to stack to object refs: some of these refs live in the C stack, and
Ruby doesn’t know the layout of that so it has to assume that anything that looks like a pointer is one.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Matt</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>11 Jul 2005</NOBR> at <NOBR>07:55</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>why – I thought that was the case, but it only seems to work with blocks, not begin..end</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Timmy</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>12 Jul 2005</NOBR> at <NOBR>09:04</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><CODE>
irb(main):001:0&gt; x
NameError: undefined local variable or method `x' for main:Object
        from (irb):1
irb(main):002:0&gt; begin
irb(main):003:1* x = 1
irb(main):004:1&gt; end
=&gt; 1
irb(main):005:0&gt; x
=&gt; 1
</CODE></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Timmy</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>12 Jul 2005</NOBR> at <NOBR>09:07</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Sorry about that. I thought I was getting linebreaks with my ‘code’ tag. Here it is again (doesn’t this show that variables created inside begin..end survive after the end?):</P>
<PRE><CODE>
irb(main):001:0&gt; x
NameError: undefined local variable or method `x' for main:Object
        from (irb):1
irb(main):002:0&gt; begin
irb(main):003:1* x = 1
irb(main):004:1&gt; end
=&gt; 1
irb(main):005:0&gt; x
=&gt; 1
</CODE>
</PRE></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Matt</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>12 Jul 2005</NOBR> at <NOBR>11:44</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Yeah, that was the exact same result I was getting.  Is this something that changed with 1.9 perhaps?</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Timmy</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>12 Jul 2005</NOBR> at <NOBR>11:49</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>No, I get the same results when I do it on 1.9.0.</P>
	<P>In a message on ruby-talk, Yohanes Santoso makes a distinction between “declaring scope” and “variable scope” which I suspect has something to do with this. Anybody able to elaborate on this distinction?</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Timmy</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>12 Jul 2005</NOBR> at <NOBR>12:54</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Ok, I’m getting very sad now. When I run the CustObj code listed above I never get rid of Object #1. Even after exiting the scope and executing GC.start, it still persists. The only object that ever disappears is Object #5. What is going on here – why are we getting different results? (And while we’re at it, why wasn’t Yohanes Santoso able to reproduce TaQ’s results in the ruby-talk thread in question?)</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>mfp</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>13 Jul 2005</NOBR> at <NOBR>09:53</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>First of all: don’t expect any  of this to be 100% reproducible. Your C stack is probably different from mine. The above results illustrate this too.</P>
<PRE><CODE>
batsman@tux-chan:/tmp$ cat gc.rb
class CustObj
    attr_accessor :val, :next
    def initialize(v,n=nil)
        @val        = v
        @next       = n
    end
    def to_s
        "Object #{@val} (#{self.object_id}) points to " \
        "#{@next.nil? ? 'nothing' : @next.val} " \
            "(#{@next.nil? ? '':@next.object_id})" 
    end
end
def list
    print "Listing all CustObj's with ObjectSpace\n" 
    print "#{ObjectSpace.each_object(CustObj) {|v| puts v}}" \
        " objects found\n\n" 
end
def b
    begin        # start a new scope so we can exit it later
        c1 = CustObj.new(1,CustObj.new(2,CustObj.new(3)))
        c4 = CustObj.new(4,CustObj.new(5))
        c6 = CustObj.new(6)
        c1.next.next.next = c1        # comment this and check again
        puts "### Initial" 
        list

        c1 = nil
        c4.next = nil

        GC.start

        puts "### After gc, but still within declaring scope" 
        list
    end

    puts "### I shall die now if begin/end introduces a new scope" 
    a, b = c1, c6  # proves that the vars aren't dead here
    puts "### Well, I guess there's no new scope after all" 

    puts "### Exited the non-scope" 
    list

    GC.start                        # bleh

    puts "### After gc, outside of declaring scope" 
    list
end
b
# &lt; &lt; EOF =&gt; mangled msg
# &lt;&lt;-EOF works just fine
puts &lt;&lt;-EOF
Whatever objects were alive before will remain here: there's
something in the C stack that *seems* to point to them. Ruby's GC
*is* conservative, so there is no guarantee that the objects will be
collected (most will, eventually), let alone reclaimed in a timely
manner.
EOF
GC.start                        # die
list
batsman@tux-chan:/tmp$ ruby gc.rb
### Initial
Listing all CustObj's with ObjectSpace
Object 6 (537823986) points to nothing ()
Object 4 (537823996) points to 5 (537824006)
Object 5 (537824006) points to nothing ()
Object 1 (537824016) points to 2 (537824026)
Object 2 (537824026) points to 3 (537824036)
Object 3 (537824036) points to 1 (537824016)
6 objects found
### After gc, but still within declaring scope
Listing all CustObj's with ObjectSpace
Object 6 (537823986) points to nothing ()
Object 4 (537823996) points to nothing ()
Object 1 (537824016) points to 2 (537824026)
Object 2 (537824026) points to 3 (537824036)
Object 3 (537824036) points to 1 (537824016)
5 objects found
### I shall die now if begin/end introduces a new scope
### Well, I guess there's no new scope after all
### Exited the non-scope
Listing all CustObj's with ObjectSpace
Object 6 (537823986) points to nothing ()
Object 4 (537823996) points to nothing ()
Object 1 (537824016) points to 2 (537824026)
Object 2 (537824026) points to 3 (537824036)
Object 3 (537824036) points to 1 (537824016)
5 objects found
### After gc, outside of declaring scope
Listing all CustObj's with ObjectSpace
Object 6 (537823986) points to nothing ()
Object 4 (537823996) points to nothing ()
2 objects found
Whatever objects were alive before will remain here: there's
something in the C stack that *seems* to point to them. Ruby's GC
*is* conservative, so there is no guarantee that the objects will be
collected (most will, eventually), let alone reclaimed in a timely
manner.
Listing all CustObj's with ObjectSpace
Object 6 (537823986) points to nothing ()
Object 4 (537823996) points to nothing ()
2 objects found
</CODE>
</PRE></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>why</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>13 Jul 2005</NOBR> at <NOBR>10:21</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Okay, so the <CODE>begin..end</CODE> doesn’t introduce its own local variables.
 It doesn’t leverage <CODE>local_push</CODE>.  Is it effective in clearing GC,
though?  And why?  Look through Ruby’s source, it looks like the <CODE>begin..end</CODE> is just a collection of nodes,  nothing more.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>MenTaLguY</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>13 Jul 2005</NOBR> at <NOBR>10:33</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Can someone verify that Ruby does in fact walk the C stack?  I’d be surprised if it did, as that would seriously reduce its portability…</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>mfp</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>13 Jul 2005</NOBR> at <NOBR>15:49</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent">MenTaLguY: it <STRONG>has to</STRONG> look at the C stack (and mark the objects pointed to by the registers too). Otherwise, writing extensions would be quite a PITA . Read garbage_collect() around:
<PRE><CODE>
#if STACK_GROW_DIRECTION &lt; 0
    rb_gc_mark_locations((VALUE*)STACK_END, rb_gc_stack_start);
#elif STACK_GROW_DIRECTION &gt; 0
    rb_gc_mark_locations(rb_gc_stack_start, (VALUE*)STACK_END + 1);
#else
    if ((VALUE*)STACK_END &lt; rb_gc_stack_start)
        rb_gc_mark_locations((VALUE*)STACK_END, rb_gc_stack_start);
    else
        rb_gc_mark_locations(rb_gc_stack_start, (VALUE*)STACK_END + 1);
#endif
</CODE>
</PRE></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>MenTaLguY</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>14 Jul 2005</NOBR> at <NOBR>16:29</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Ahh, so it does.  And indeed I suspect that is the reason for all the various interesting GC behavior being described here.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>mfp</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>15 Jul 2005</NOBR> at <NOBR>11:11</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>We can easily go beyond the mere suspicion:</P>
<PRE><CODE>
batsman@tux-chan:/tmp$ cat gc.rb
class CustObj
    attr_accessor :val, :next
    def initialize(v,n=nil)
        @val        = v
        @next       = n
    end
    def to_s
        "Object #{@val} (#{self.object_id}) points to " \
        "#{@next.nil? ? 'nothing' : @next.val} " \
            "(#{@next.nil? ? '':@next.object_id})" 
    end
end
def list
    print "Listing all CustObj's with ObjectSpace\n" 
    print "#{ObjectSpace.each_object(CustObj) {|v| puts v}}" \
        " objects found\n\n" 
end
def b
    begin   # start a new scope so we can exit it later
        c4 = CustObj.new(4,CustObj.new(5))
        c6 = CustObj.new(6)
        c1 = CustObj.new(1,CustObj.new(2,CustObj.new(3)))
        c1.next.next.next = c1     # comment this and check again
        puts "### Initial" 
        list

  (2**100).abs # just to set the breakpoint

        c1 = nil
        c4.next = nil

        puts "### ABOUT TO GC!!" 

        GC.start

        puts "### After gc, but still within declaring scope" 
        list
    end

   puts "### Exited the non-scope" 
    list

    GC.start                     # here I want c1 to disappear

    puts "### After gc, outside of declaring non-scope" 
    list
end
b
</CODE>
</PRE>
	<P>Let’s run that under gdb:</P>
<PRE><CODE>
batsman@tux-chan:/tmp$ gdb ~/usr/bin/gruby
(gdb) set args gc.rb
</CODE>
</PRE>
	<P>We set a breakpoint at rb_big_abs in order to get the object_id of the first object and set a conditional breakpoint based on that:</P>
<PRE><CODE>
(gdb) break rb_big_abs
Breakpoint 1 at 0x80c72e9: file bignum.c, line 1994.
(gdb) run
Starting program: /home/batsman/usr/bin/gruby gc.rb
### Initial
Listing all CustObj's with ObjectSpace
Object 1 (537824326) points to 2 (537824336)
Object 2 (537824336) points to 3 (537824346)
Object 3 (537824346) points to 1 (537824326)
Object 6 (537824356) points to nothing ()
Object 4 (537824366) points to 5 (537824376)
Object 5 (537824376) points to nothing ()
6 objects found
Breakpoint 1, rb_big_abs (x=1075647532) at bignum.c:1994
1994        if (!RBIGNUM(x)-&gt;sign) {
(gdb) list gc_mark
705
706     void
707     gc_mark(ptr, lev)
708         VALUE ptr;
709         int lev;
710     {
711         register RVALUE *obj;
712
713         obj = RANY(ptr);
714         if (rb_special_const_p(ptr)) return; /* special const not marked */
</CODE>
</PRE>
	<P>Now we can see when the first object is about to be marked:</P>
<PRE><CODE>
(gdb) break gc_mark
Breakpoint 2 at 0x806e0f3: file gc.c, line 713.
(gdb) cond 2 ptr == 2 * 537824326
(gdb) cont
Continuing.
### ABOUT TO GC!!
Breakpoint 2, gc_mark (ptr=1075648652, lev=0) at gc.c:713
713         obj = RANY(ptr);
</CODE>
</PRE>
	<P>Breakpoint reached. Let’s see what caused that object to be marked (i.e. where the reference came from):</P>
<PRE><CODE>
(gdb) bt
#0  gc_mark (ptr=1075648652, lev=0) at gc.c:713
#1  0x0806dfb9 in mark_locations_array (x=0xbfffe188, n=1395) at gc.c:626
#2  0x0806dfe7 in rb_gc_mark_locations (start=0xbfffde08, end=0xbffff758) at gc.c:639
#3  0x0806f0e6 in garbage_collect () at gc.c:1356
[...]
</CODE>
</PRE>
	<P>Alright, there was a ref in the C stack.
Let’s cont until the current stack frame returns…</P>
<PRE><CODE>
(gdb) finish
Run till exit from #0  gc_mark (ptr=1075648652, lev=0) at gc.c:713
Breakpoint 2, gc_mark (ptr=1075648652, lev=3) at gc.c:713
713         obj = RANY(ptr);
(gdb) bt
#0  gc_mark (ptr=1075648652, lev=3) at gc.c:713
#1  0x0806e001 in mark_entry (key=10274, value=1075648652, lev=3) at gc.c:648
#2  0x080af3d7 in st_foreach (table=0x812c688, func=0x806dfe9 &lt;mark_entry&gt;, arg=3) at st.c:496
#3  0x0806e030 in mark_tbl (tbl=0x812c688, lev=3) at gc.c:658
#4  0x0806e51e in gc_mark_children (ptr=1075648692, lev=3) at gc.c:948
#5  0x0806e195 in gc_mark (ptr=1075648692, lev=2) at gc.c:731
#6  0x0806e001 in mark_entry (key=10274, value=1075648692, lev=2) at gc.c:648
#7  0x080af3d7 in st_foreach (table=0x812c700, func=0x806dfe9 &lt;mark_entry&gt;, arg=2) at st.c:496
#8  0x0806e030 in mark_tbl (tbl=0x812c700, lev=2) at gc.c:658
#9  0x0806e51e in gc_mark_children (ptr=1075648672, lev=2) at gc.c:948
#10 0x0806e195 in gc_mark (ptr=1075648672, lev=1) at gc.c:731
#11 0x0806e001 in mark_entry (key=10274, value=1075648672, lev=1) at gc.c:648
#12 0x080af3d7 in st_foreach (table=0x812c778, func=0x806dfe9 &lt;mark_entry&gt;, arg=1) at st.c:496
#13 0x0806e030 in mark_tbl (tbl=0x812c778, lev=1) at gc.c:658
#14 0x0806e51e in gc_mark_children (ptr=1075648652, lev=1) at gc.c:948
#15 0x0806e195 in gc_mark (ptr=1075648652, lev=0) at gc.c:731
#16 0x0806dfb9 in mark_locations_array (x=0xbfffe188, n=1395) at gc.c:626
#17 0x0806dfe7 in rb_gc_mark_locations (start=0xbfffde08, end=0xbffff758) at gc.c:639
#18 0x0806f0e6 in garbage_collect () at gc.c:1356
[...]
</CODE>
</PRE>
	<P>Isn’t this beautiful?
obj1@1075648652 references obj2@1075648672,  which is marked in gc_mark_children, which iterates over the entries in the iv_tbl.
Likewise, obj2@1075648672 points to obj3@1075648692, which points back to obj1@1075648652. This is why we ran into the gc_mark breakpoint for the second time (!).</P>
<PRE><CODE>
(gdb) cont
Continuing.
### After gc, but still within declaring scope
Listing all CustObj's with ObjectSpace
Object 1 (537824326) points to 2 (537824336)
Object 2 (537824336) points to 3 (537824346)
Object 3 (537824346) points to 1 (537824326)
Object 6 (537824356) points to nothing ()
Object 4 (537824366) points to nothing ()
5 objects found
### Exited the non-scope
Listing all CustObj's with ObjectSpace
Object 1 (537824326) points to 2 (537824336)
Object 2 (537824336) points to 3 (537824346)
Object 3 (537824346) points to 1 (537824326)
Object 6 (537824356) points to nothing ()
Object 4 (537824366) points to nothing ()
5 objects found
### After gc, outside of declaring non-scope
Listing all CustObj's with ObjectSpace
Object 6 (537824356) points to nothing ()
Object 4 (537824366) points to nothing ()
2 objects found
Program exited normally.
(gdb) quit
</CODE>
</PRE></DIV></DIV>
</DIV>


  <DIV class="entry">
    <P><SMALL>Comments are closed for this entry.</SMALL></P>
  



        </DIV> 

</DIV>



</DIV>





</DIV></BODY></HTML>