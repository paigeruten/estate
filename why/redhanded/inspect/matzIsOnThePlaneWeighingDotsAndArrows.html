<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0112)redhanded.hobix.com/inspect/matzIsOnThePlaneWeighingDotsAndArrows.html -->
<HTML xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><HEAD><META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--<BASE href="http://redhanded.hobix.com.wstub.archive.org/inspect/matzIsOnThePlaneWeighingDotsAndArrows.html">--><BASE href=".">


<TITLE>RedHanded » Matz is on the Plane, Weighing Dots and Arrows</TITLE>
<LINK rel="shortcut icon" href="../favicon.ico" type="image/vnd.microsoft.icon" />
<LINK rel="icon" href="../favicon.ico" type="image/vnd.microsoft.icon" />
<META http-equiv="Pragma" content="no-cache">
<META http-equiv="Expires" content="-1">




<STYLE type="text/css">
 @import "../site.css"; 
</STYLE>
</HEAD><BODY>

<DIV id="page">

<DIV id="hoodwinkd">
  <A href="http://hoodwinkd.hobix.com/"><SPAN>hoodwink.d enhanced</SPAN></A>

</DIV>
<DIV id="buttons">
<DL class="tab">
  <DT><A title="Syndicate this Site" href="index.xml">RSS</A></DT>
  <DD><A title="Syndicate this Site" href="index.xml">2.0</A></DD>
</DL>
<DL class="tab xhtml">
  <DT><A title="Validate this Site" href="http://validator.w3.org/check?uri=http://redhanded.hobix.com/">XHTML</A></DT>
  <DD><A title="Validate this Site" href="http://validator.w3.org/check?uri=http://redhanded.hobix.com/">1.0</A></DD>
</DL>
</DIV>
<H1 class="title"><A href="../"><IMG src="../images/redhanded.gif" alt="RedHanded"></A></H1>
<DIV id="banner">
  <DIV class="tagline">sneaking Ruby through the system</DIV>
  <DIV class="nav"><A href="../5.gets/">5.gets</A> | <A href="../bits/">bits</A> | 
    <A href="../inspect/">inspect</A> | <A href="../cult/">the cult</A> | <A href="../-h/">-h</A></DIV>
</DIV>


<DIV id="content">
<DIV id="sidebar">
<P>New to RedHanded? <A href="../-h/pardonAndWelcome.html">About our sections.</A></P>

<DIV class="sidebarBox">
<H2 class="sidebarTitle">Archive</H2>
<UL>

    <LI><A href="../2004/12/">December 2004</A></LI>

    <LI><A href="../2005/01/">January 2005</A></LI>

    <LI><A href="../2005/02/">February 2005</A></LI>

    <LI><A href="../2005/03/">March 2005</A></LI>

    <LI><A href="../2005/04/">April 2005</A></LI>

    <LI><A href="../2005/05/">May 2005</A></LI>

    <LI><A href="../2005/06/">June 2005</A></LI>

    <LI><A href="../2005/07/">July 2005</A></LI>

    <LI><A href="../2005/08/">August 2005</A></LI>

    <LI><A href="../2005/09/">September 2005</A></LI>

    <LI><A href="../2005/10/">October 2005</A></LI>

    <LI><A href="../2005/11/">November 2005</A></LI>

    <LI><A href="../2005/12/">December 2005</A></LI>

    <LI><A href="../2006/01/">January 2006</A></LI>

    <LI><A href="../2006/02/">February 2006</A></LI>

    <LI><A href="../2006/03/">March 2006</A></LI>

    <LI><A href="../2006/04/">April 2006</A></LI>

    <LI><A href="../2006/05/">May 2006</A></LI>

    <LI><A href="../2006/06/">June 2006</A></LI>

    <LI><A href="../2006/07/">July 2006</A></LI>

    <LI><A href="../2006/08/">August 2006</A></LI>

    <LI><A href="../2006/09/">September 2006</A></LI>

    <LI><A href="../2006/10/">October 2006</A></LI>

    <LI><A href="../2006/11/">November 2006</A></LI>

    <LI><A href="../2006/12/">December 2006</A></LI>

    <LI><A href="../2007/01/">January 2007</A></LI>

    <LI><A href="../2007/02/">February 2007</A></LI>

    <LI><A href="../2007/03/">March 2007</A></LI>

    <LI><A href="../2007/04/">April 2007</A></LI>

    <LI><A href="../2007/05/">May 2007</A></LI>

</UL>
</DIV>

<P><A href="http://www.pragmaticprogrammer.com/titles/ruby/index.html"><IMG src="../images/prag-ruby-book.jpg" alt="PickAxe II"></A><BR>
<A href="http://www.pragmaticprogrammer.com/titles/ruby/index.html">Get your copy of <I>Programming Ruby</I>!</A></P>

 <DIV class="sidebarBox">
        <H2 class="sidebarTitle">Links</H2>
        <A href="http://technorati.com/tags/ruby">@technorati</A><BR>
<A href="http://del.icio.us/tag/ruby">@del.icio.us</A><BR>
<A href="http://www.flickr.com/photos/tags/ruby">@flickr</A><BR>
<A href="http://www.artima.com/articles/index.jsp?topic=ruby">@artima</A><BR>
<A href="http://blog.caboo.se/">@caboo</A><BR>
<A href="http://www.oreillynet.com/ruby">@oreilly</A><BR>
<A href="http://ruby-lang.org/">ruby</A><BR>
<A href="http://ruby-doc.org/">-&gt; docs</A><BR>
<A href="http://rubyforge.org/">-&gt; wares</A><BR>
<A href="http://rubygarden.org/ruby/">-&gt; wiki</A><BR>
<A href="http://www.sitepoint.com/forums/forumdisplay.php?f=227">-&gt; forum</A><BR>
<A href="http://www.rubyquiz.com/">-&gt; quizzes</A><BR>
<A href="http://planetruby.0x42.net/">-&gt; planet</A><BR>
<A href="http://meme.b9.com/cdates.html?channel=ruby-lang">-&gt; irc</A><BR>
<A href="http://www.rubyweeklynews.org/">rubyweeklynews</A><BR>
<A href="http://weblog.rubyonrails.com/">rails</A><BR>
<A href="http://wiki.rubyonrails.org/">-&gt; wiki</A><BR>
<A href="http://www.planetrubyonrails.org/">-&gt; planet</A><BR>
<A href="http://thesaq.com/rubyonrails/">-&gt; irc</A><BR>
<A href="http://anarchaia.org/">%anarchaia</A><BR>
<A href="http://project.ioni.st/">%projectionist</A><BR>
<A href="http://pugs.blogs.com/">~audreyt</A><BR>
<A href="http://dablog.rubypal.com/">~black</A><BR>
<A href="http://www.jamesbritt.com/">~britt</A><BR>
<A href="http://www.jamisbuck.org/jamis/">~buck</A><BR>
<A href="http://tomcopeland.blogs.com/juniordeveloper/">~copeland</A><BR>
<A href="http://eigenclass.org/">~fernandez</A><BR>
<A href="http://www.chadfowler.com/">~fowler</A><BR>
<A href="http://www.loudthinking.com/">~hansson</A><BR>
<A href="http://blog.segment7.net/">~hodel</A><BR>
<A href="http://slash7.com/">~hoy/7</A><BR>
<A href="http://fhwang.net/">~hwang</A><BR>
<A href="http://blog.leetsoft.com/">~luetke</A><BR>
<A href="http://www.worldlingo.com/wl/translate?wl_lp=JA-en&wl_glossary=gl1&wl_fl=3&wl_rurl=http%3A%2F%2Fwww.rubyist.net%2F%7Ematz%2F&wl_url=http%3A%2F%2Fwww.rubyist.net%2F%7Ematz%2F&wl_g_table=-3">~matz</A><BR>
<A href="http://moonbase.rydia.net/">~mental</A><BR>
<A href="http://techno-weenie.net/">~olson</A><BR>
<A href="http://pragprog.com/pragdave">~pragdave</A><BR>
<A href="http://www.livejournal.com/users/premshree/">~premshree</A><BR>
<A href="http://kronavita.de/chris/blog/">~neukirchen</A><BR>
<A href="http://www.robbyonrails.com/">~robby</A><BR>
<A href="http://www.rousette.org.uk/">~rousette</A><BR>
<A href="http://nubyonrails.com/">~topfunky</A><BR>
<A href="http://www.jvoorhis.com/">~voorhis</A><BR>
<A href="http://onestepback.org/">~weirich</A><BR>
<A href="http://blog.zenspider.com/">~zenspider</A><BR>
        </DIV> 
 <DIV class="sidebarBox">
        <H2 class="sidebarTitle">Syndicate</H2>
        <UL>
            <LI><A href="../index.xml">RSS 2.0</A></LI>
        </UL>
        </DIV> 
 <DIV class="sidebarBox">
        <P>Built upon <A href="http://hobix.com/">Hobix</A></P>
        </DIV> 
<IMG src="../images/redhanded-duck.gif" alt="Type the Duck">
<DIV class="email">Got a story for us? <A href="../mailto:redhanded@hobix.com">E-mail it!</A></DIV>
<DIV class="technorati"><P><A href="http://www.technorati.com/profile/whytheluckystiff">Technorati Profile</A>
<A href="http://www.technorati.com/cosmos/search.html?url=http%3A%2F%2Fredhanded.hobix.com"><BR>
<IMG src="../images/bubble_icon.gif" height="20" width="24" alt="Get Conversations about RedHanded &raquo; sneaking Ruby through the system"></A>
</P>
</DIV>

</DIV>


 <DIV id="blog">
        
<DIV class="entry">
    <H2 class="entryTitle">Matz is on the Plane, Weighing Dots and Arrows
  <SPAN class="entryPermalink"><A href="../inspect/matzIsOnThePlaneWeighingDotsAndArrows.html" title="Permanent link to &ldquo;Matz is on the Plane, Weighing Dots and Arrows&rdquo;">#</A></SPAN>
</H2>

<DIV class="entrySection">by <A href="http://whytheluckystiff.net/" title="Visit why&#39;s homepage">why</A> 
  in <A href="../inspect" title="List of entries in the &ldquo;inspect&rdquo; category">inspect</A>
</DIV>

     <DIV class="entryContent"><P>Dots or arrows?  Dots or arrows?  See, he said he was leaving for RubyConf and on the way he’d figure out this whole dots and arrows business.  Currently, arrows are winning, since they’re checked into 1.9.</P>


	<P>Nobu gives some examples in <A href="../ruby-talk/160170">ruby-talk:160170</A>:</P>


<PRE> &gt;&gt; 1.times -&gt; (foo="bar") { puts foo }
 =&gt; 0

 &gt;&gt; def y
 &gt;&gt;   yield
 &gt;&gt; end
 &gt;&gt; y -&gt; (foo="bar") { puts foo }
</PRE>

	<P>The two dotted suggestions (err.. one one-dotted and one two-dotted!) come from Christophe Grandsire, who suggests a colon, and Eric Mahurin, who offers a period (which semantically jives with method calling):</P>


<PRE> collection.each:(foo="bar){puts foo} 
 collection.each.(foo="bar){puts foo} 
</PRE>

	<P>I don’t envy the Yacc’ry ahead for Nobu and Matz.  But it’s fun to see everyone’s ears go up when the syntactical frosting comes out.  Even when it’s only a couple sprinkles.</P></DIV> 
</DIV>
<DIV class="entryFooter"> 
    <NOBR>12 Oct 2005</NOBR> at <NOBR>14:37</NOBR>
    <NOSCRIPT></NOSCRIPT>
   | 
    54 comments
</DIV>
</DIV>
<DIV id="comments">


<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Robby Russell</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>12 Oct 2005</NOBR> at <NOBR>15:01</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P> ARTIST : Harry Nilsson</P>


	<P> TITLE : Me and My Arrow</P>


	<P>The Point</P>


	<P>Me and my arrow
Straighter than narrow
Wherever we go, everyone knows
It’s me and my arrow</P>


	<P>Me and my arrow
Taking the high road
Wherever we go, everyone knows
It’s me and my arrow</P>


	<P>And in the morning when I wake up
She may be gone, I don’t know
And if we make up just to break up
I’ll carry on, oh yes I will</P>


	<P>Me and my arrow, Do-do-loo-do, do-do do-do do do
Straighter than narrow
Wherever we go, everyone knows
It’s me and my arrow</P>


	<P>Me and my arrow (5X)</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>\-&gt;</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>12 Oct 2005</NOBR> at <NOBR>15:18</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Even though \ has been thrown out because of problems with some encodings (turns up as a yen symbol sometimes), I still think it should be considered. Possibly one of two ways to do it?</P>


	<P>I guess I’ve grown too fond of</P>


<CODE><PRE>\x y -&gt; x + y </PRE></CODE>

	<P>in Haskell.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>&lt;|:{</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>12 Oct 2005</NOBR> at <NOBR>15:23</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>OK, what was the problem we were trying to solve with this new syntax again?</P>


	<P>Oh, yeah, it’s so we can give default values to block params.
Something I don’t think I’ve ever really needed….
(something I <EM>have</EM> needed, though, is to be able to give a block-scoped variable an initial value so that… oh, forget about that)</P>


	<P>I’m hoping this doesn’t mean that the old ’|var|’ thing isn’t going away…  So would this still be valid:
collection.each {|item| puts item }
?</P>


	<P>If not, I’m really going to miss it.  And I’m really not going to be happy.  I really hope this is being proposed as an alternative syntax, not a replacement for the current one.  I really, really hope…  What’s Matz’s number so I can call him on the plane?</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>MenTaLguY</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>12 Oct 2005</NOBR> at <NOBR>15:57</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>I vote arrow, myself.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>rynok</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>12 Oct 2005</NOBR> at <NOBR>15:58</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent">I haven’t really been following this either, but I agree, it would be sad if we lost:
<PRE><CODE>collection.each {|item| ... }</CODE></PRE>

That form certainly looks more elegant (and seems more intuitive) than:
<PRE><CODE>collection.each -&gt; (item) { ... }</CODE></PRE>

	<P>Or maybe I’m just so accustomed to it…</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>MenTaLguY</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>12 Oct 2005</NOBR> at <NOBR>15:58</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>And yes, I would be truly sad to see the demise of goalposts, if it came to that.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>JB</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>12 Oct 2005</NOBR> at <NOBR>15:59</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>I agree mostly with &lt;|:{.  I really like the current “collection.each {|item| puts item }” style.  Along with the ”|var| do” blocks.</P>


	<P>Of the three new styles mentioned here, I think I prefer the colon approach.  It is probably me overreacting, but → is a bit awkward and speed robbing.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Dan</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>12 Oct 2005</NOBR> at <NOBR>17:28</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Wow, matz wasn’t kidding when he said he wants to maximize breakage before 2.0. This affects every thing in ruby I’ve ever done. Unless I am reading this the wrong way, and we are keeping—</P>


<CODE>object.method { |item| ... }</CODE>

	<P>Which I think is the case here…</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>&lt;|:{</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>12 Oct 2005</NOBR> at <NOBR>17:53</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>If the goalposts are going, I can see the headlines now:  REVOLT  at  RUBYCONF !</P>


	<P>Save the goalposts! Default block params just aren’t worth it.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>{|..|}</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>12 Oct 2005</NOBR> at <NOBR>17:55</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Please Help!  I’m endangered!</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>&lt;|:{</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>12 Oct 2005</NOBR> at <NOBR>18:00</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Now that a syntactic face has been put on this impending tragedy ‘{|..|}’ maybe Matz will have mercy.  How could he eliminate this cute little fellow:</P>


	<P>{|..|}</P>


	<P>Now we just need to give him a name.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Dan</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>12 Oct 2005</NOBR> at <NOBR>18:20</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Oh god, just fix the parser instead of tearing up the syntax, please!</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Danno</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>12 Oct 2005</NOBR> at <NOBR>18:34</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P> DEATH TO DOTS AND ARROWS !</P>


	<P> GOALPOSTS FOR LIFE !</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>grammarian</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>12 Oct 2005</NOBR> at <NOBR>18:40</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>I trust Matz will duly take into account the potential havoc his decision might wreak on the Poignant Guide.</P>


	<P>To wit:</P>


	<BLOCKQUOTE>
		<P>I like to think of the pipe characters as representing a tunnel. They give the appearance of a chute that the variables are sliding down. (An x goes down spread eagle, while the y neatly crosses her legs.) This chute acts as a passageway between blocks and the world around them.</P>
	</BLOCKQUOTE>


	<BLOCKQUOTE>
		<P>Variables are passed through this chute (or tunnel) into the block.</P>
	</BLOCKQUOTE>


	<BLOCKQUOTE>
		<P><CITE><SUB>PoignantGuide.Chapter(3).BlockArguments</SUB></CITE></P>
	</BLOCKQUOTE></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>&lt;|:{</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>12 Oct 2005</NOBR> at <NOBR>18:57</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>The beauty of that passage from the PoignantGuide would be mared by dots and arrows.  Perhaps it would have to be changed to read something like:</P>


	<BLOCKQUOTE>
		<P>I like to think of the arrow being shot into the variables x and y killing them… but all is not lost, they are resurrected to start a new life in the block ahead….</P>
	</BLOCKQUOTE>


	<P>No, that just doesn’t work.  The arrow operator is just too violent and reminicent of that barbaric language C.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Trejkaz</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>12 Oct 2005</NOBR> at <NOBR>19:49</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>What’s the point of this?  To make it easier for the computer to parse and harder for the human to parse?  I could have sworn that the readability was half the point of using Ruby in the first place.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>MenTaLguY</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>12 Oct 2005</NOBR> at <NOBR>19:59</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P><CODE>{|..|}</CODE> looks rather like the Prince from Katamari Damacy, minus antenna.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>forever {|..|}</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>12 Oct 2005</NOBR> at <NOBR>20:01</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Aha!  I found the “<A href="http://ruby-talk.org/cgi-bin/scat.rb/ruby/ruby-talk/160045">reason</A>.”</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Albert</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>12 Oct 2005</NOBR> at <NOBR>20:18</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Perhaps this is extreme but why not get rid of bitwise or. I don’t think it’s used often enough to justify its own symbol, and we could just use <CODE>bitor</CODE> (or something equivalent) to do the same thing.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Trejkaz</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>12 Oct 2005</NOBR> at <NOBR>20:44</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Or, why not just make the parser say that the first <CODE>|</CODE> is the end of the block parameters, period… if you want to use bitwise or inside a default parameter (which is pretty bloody unlikely,  IMO ) you can put it in <CODE>(</CODE>..<CODE>)</CODE>.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>&lt;|:{</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>12 Oct 2005</NOBR> at <NOBR>21:00</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Albert: No, we should not get rid of bitwise OR.  I would suggest that this whole idea of needing to create a mechanism for default arguments to blocks is a solution in search of a problem.  I think the whole idea should be dropped because it is of such limited use.  Sure it might come in handy in some very special cases that might crop up less than 1% of the  of the time – why mess up Ruby’s syntax just for such a small gain?  In my five years of Ruby programming I can think of one time where I said, “Gee, it would be nice to have default arguments to blocks” – and then I worked around it (not very hard to do).  Better to have some inconvenience for that very special case than to make this kind of change that inconveniences a lot of people and totally breaks current code.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>&lt;|:{</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>12 Oct 2005</NOBR> at <NOBR>21:24</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent">forever {|..|}: so apparently yacc is keeping us from having this nice syntax:
	<BLOCKQUOTE>
		<P>lambda { |foo = bar| puts foo }</P>
	</BLOCKQUOTE>


	<P>This seems like the ‘correct’ syntax for default block arguments.  It looks great.  But yacc doesn’t like it apparently.  Should yacc dictate our language design?  I say NO!</P>


	<P>If we can’t have something nice and intuitive like:</P>


	<BLOCKQUOTE>
		<P>lambda { |foo = bar| puts foo }</P>
	</BLOCKQUOTE>


	<P>then we should either:
1) wait for a better yacc that could handle it (probably not possible)
2)find another parser generator for Ruby (ANTLR?) or perhaps even have the Ruby parser written in Ruby (that would have lots of advantages – though a disadvantage could be slowness.)</P>


Actually, come to think of it, why can’t yacc handle:
	<BLOCKQUOTE>
		<P>lambda { |foo = bar| puts foo }</P>
	</BLOCKQUOTE>


	<P>?</P>


	<P>We all know Matz is brilliant, but maybe yacc isn’t his thing.  Any yacc experts out there who can help us out?  I’d hate to see Ruby’s syntax get messed up because of yacc limitations (or perceived limitations)... come to think of it, it probably isn’t possible in yacc because of the bitwise OR thing.  Would it be too require that bitwise OR not be allowed between the goalposts?  They aren’t allowed now, so what’s the big deal? Or, we could say that you have to use ‘or’ not ’|’.   Or if you insist on using a bitwise OR between the goalposts you’ve gotta enclose the whole experession in ‘(..)’.  Doesn’t seem like much to ask.</P>


	<P>Or what if an alternate syntax were allowed:</P>


	<BLOCKQUOTE>
		<P>lambda {(foo=bar|baz) puts foo }</P>
	</BLOCKQUOTE>


	<P>...Ah, but now they’ve got me playing their game.  I say we just say NO.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Trejkaz</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>12 Oct 2005</NOBR> at <NOBR>21:37</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>To explain why they’re looking at default parameters in blocks, suppose you want to dynamically define a method (such as what all that metaprogramming jazz does.)  A nice, sensible way to do that is to pass the method logic as a block.</P>


	<P>Now, what do suppose you would do if the method you wanted to define had default values for some parameters?</P>


	<P>But I agree that if  YACC  is really the problem here, then off with its head.  Isn’t the Perl parser/lexer written in Perl?  Maybe that was an urban legend… ;-)</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Andrew</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>12 Oct 2005</NOBR> at <NOBR>23:48</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P> IMO ,
lambda { |foo = bar| puts foo }
is by far the best.</P>


	<P>If yacc truly can’t handle it, than maybe an alternative to yacc needs to be found.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>crzwdjk</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>13 Oct 2005</NOBR> at <NOBR>00:04</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>The arrows they’re just stealing from perl. And in perl they do like kind of nice:</P>


	<PRE><CODE>for @list -&gt; $item {...}</CODE></PRE>


	<P>or</P>


	<PRE><CODE>@list.map -&gt; $i { f $i }</CODE></PRE>


	<P>or even</P>


	<PRE><CODE>while readline() -&gt; $line { ... }</CODE></PRE>


	<P>From the perspective of someone who doesn’t live and breathe ruby, the arrow visually puts the parameter list between the block-caller and the block, which is where it belongs semantically. Plus this way blocks looks visually more like functions.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Ezra</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>13 Oct 2005</NOBR> at <NOBR>00:12</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>There was a big duscussion about this stuff on ruby-talk back in August. Matz said the {|..|} would never go away. And I quote:</P>


	<P>|I think one of the first things that attracted me to ruby is the {| 
|x|...} syntax. So please leave my happy little blocks alone. Or at  
|least leave them as an option.</P>


	<P>Don’t worry.  The block syntax will not be changed.  Never.</P>


	<PRE><CODE>matz.</CODE></PRE></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>_why cult follower</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>13 Oct 2005</NOBR> at <NOBR>00:18</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>I say we all learn Python. Just to see how hell <EM>really</EM> looks like.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Tsela</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>13 Oct 2005</NOBR> at <NOBR>00:52</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent">Everyone would rather have:
<PRE><CODE>
{|foo=bar| ... }
</CODE>
</PRE>
That much is clear. But yacc makes it impossible, and more important matz seems <STRONG>unwilling</STRONG> to change parser. So discussions about the parser itself are likely to lead to nothing (short of someone making a patch to make yacc work in a way that would allow the above syntax).

	<P>So if we are going to have a new syntax for blocks with default argument values (and we are going to, despite what the opponents might have liked), let’s have a nice one at least. It may not be used often (thank God!), but at least one’s eyes won’t jump out of their sockets if they come across code using it. And the current syntax <STRONG>stays</STRONG>, so nobody has to change their habits if they don’t want to.</P>


	<P> BTW , I am Christophe Grandsire, the one that proposed the colon syntax. I just want to make clear that I have no big attachment to this subject. I just want every feature of Ruby’s syntax to fit in the whole, even if this is a controversial one. And that arrow just jumps out and bites your nose. At least there are precedents in Ruby for the use of the colon, so it doesn’t hurt as much.</P>


	<P>Anyway, the important thing at least is this:
<B>Do not worry: {|..|} is not going away! The new syntax is just an <I>alternative</I> syntax (with one additional feature), <I>not</I> a replacement of the current one.</B></P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>-&gt;(i){i.love.arrows}</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>13 Oct 2005</NOBR> at <NOBR>01:30</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Hug and Kisses lads. Me thinks, I’ve been struck by Cupids Arrow.</P>


<PRE>    _ _
   ( V ) 
 &lt;--\ /--&lt;&lt;
     V 
</PRE>

	<P>I love arrows.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>zimbatm</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>13 Oct 2005</NOBR> at <NOBR>02:59</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent">And why was
<PRE>x = def (x,y) { ... }</PRE>
rejected ? Or just add a block keyword.

I also like javascript’s way of using lambdas. If you want to change the scope, just use the base method.
Like :
<PRE>var x = function(x,y) { js-code }.base(this)</PRE></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Thomas</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>13 Oct 2005</NOBR> at <NOBR>03:30</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Why not just use := for assignment of defaults in blocks, eg</P>


	<P>lambda { |foo := ‘bar’| puts foo }</P>


	<P>It reminds me of good ol’ Pascal.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>hgs</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>13 Oct 2005</NOBR> at <NOBR>03:53</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>I <STRONG>really</STRONG> don’t want \
because escaping things is already done with \ so it crops up everywhere in the regexp %Q(world). [Without looking it up, what’s the gsub expression for substituting \\ for \ again?]  Even !^ would be better: a kit of parts to make a lambda.</P>


	<P>Maybe if block, lambda and proc are so subtle in their difference we should just have a block  keyword and do:</P>


<PRE>block(param = "default")
  p param
end</PRE></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Dan</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>13 Oct 2005</NOBR> at <NOBR>04:43</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Can anyone give a good example of when a block needs a default value? The example given in the article, <CODE>1.times -&gt; (foo="bar") { puts foo }</CODE>, is not that great (just do <CODE>puts "bar"</CODE>!. Same with #each—when the hell would “bar” be printed?</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Tsela</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>13 Oct 2005</NOBR> at <NOBR>05:54</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent">Thomas: because the problem is not the equal sign but the goalpost ”|”. Your proposal would still not make:
<CODE>
{|foo:=(a|b)| puts foo}
</CODE>
possible. Yacc doesn’t seem to be able to handle that.

	<P>Dan: when you want to create a method with <CODE>define_method</CODE> and a block, the block arguments become the method arguments. What if you want to create a method with default argument values? You can’t right now. Another possibility I can think of (but it may be a bit contrived) is a hash where some values are <CODE>nil</CODE>, and you want to loop through it with all <CODE>nil</CODE>’s replaced by some valid value. And then there’s registering callbacks, where it may be of some use (I’m out on a limb here, having just begun to toy with Ruby-Gnome :) ).</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>sporkmonger</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>13 Oct 2005</NOBR> at <NOBR>08:05</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Groovy had this exact same problem.  This is what they used:</P>


<PRE>{ foo = 1|2 -&gt; puts foo }
</PRE>

	<P>If we’re going to <EM>insist</EM> on default parameters within blocks, I think everything should stay within the braces.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>sporkmonger</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>13 Oct 2005</NOBR> at <NOBR>08:12</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>A question:</P>


	<P>Would yacc complain if we demanded that all default parameters within block be surrounded by parens?</P>


	<P>For example:</P>


<PRE>{ |foo = (1|2)| puts foo }
</PRE>

	<P>and</P>


<PRE>{ |foo = (2)| puts foo }
</PRE></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>JES</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>13 Oct 2005</NOBR> at <NOBR>08:36</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>“Should yacc dictate our language design? I say NO!”</P>


	<P>Couldn’t agree more. Computers are slaves – we are masters. That being said, we still live in the real world. Is  YACC  patchable?</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>xml-blog.com</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>13 Oct 2005</NOBR> at <NOBR>08:53</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Not that I’m qualified as a language designer, but how about:</P>


	<P>{|foo ~ bar| puts foo}</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>jvoorhis</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>13 Oct 2005</NOBR> at <NOBR>10:29</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Now that I’ve seen that Groovy example, I’m wondering why the chute was ever necessary. A wall would have worked fine.</P>


<CODE>{ x, y | x * y }</CODE>

	<P>Not that it much matters at this point :)</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>brasilian_guy</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>13 Oct 2005</NOBR> at <NOBR>11:58</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent">jvoorhis: the most common case is the block without parameters? If so, then you are wrong; if not, then you are right:
<PRE><CODE>
a.each { puts "one more" }
</CODE></PRE>
would become
<PRE><CODE>
a.each {| puts "one more" }
</CODE></PRE>
and
<PRE><CODE>
a.each { | e | puts e }
</CODE></PRE>
would become
<PRE><CODE>
a.each { e | puts e }
</CODE></PRE>
but anyway you are not attacking the problem: matz is having some difficulty in making yacc swallow
<PRE><CODE>
a.each { |c = (b|d)| puts c }
</CODE></PRE>
because yacc stops reading the arglist at the second pipe symbol (|)</DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>riffraff</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>13 Oct 2005</NOBR> at <NOBR>12:41</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>people may ignore this, but yacc already dictated our language. 
the reason Why ruby does not have
 if a &gt; b &gt; c 
meaning
 if(b &lt;a&gt;c)
is that yacc is not able to parse it. 
Come one  ANTLR  guys, let’s remove the ugly parse.y!</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>riffraff</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>13 Oct 2005</NOBR> at <NOBR>12:43</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent">sorry, meant to hit preview.. 
I was saying: 
<PRE> if a &gt; b &gt; c </PRE>
meaning
<PRE> if (a&gt;b) and (b&gt;c)</PRE></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>batkins</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>13 Oct 2005</NOBR> at <NOBR>17:21</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>It seems like part of the rationale behind this is that default values for block variables would let define_method do everything a def can.</P>


<CODE>
   def x( a, b = 332332, * c )
</CODE>

	<P>would be identical to</P>


<CODE>
   define_method :x do |a, b = 332332, *c |
</CODE>

	<P>That said, I think the arrow syntax is way ugly, and is a lose.</P>


	<P>But is it really  YACC ’s fault that bitwise-OR’s inside goalposts cause problems?  That seems like a difficult situation to resolve no matter what parsing software you’re using.</P>


	<P>And, whoa,  ANTLR  is not the answer.  Why make the entire muckiness of Java a requirement for building Ruby?</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>&lt;|:{</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>13 Oct 2005</NOBR> at <NOBR>20:40</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Oh, yeah,  ANTLR  is written in Java now instead of C++.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>jvoorhis</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>14 Oct 2005</NOBR> at <NOBR>01:06</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>brasilian_guy:</P>


	<P>The point wasn’t to attack the problem, it was just a thought I had on the block syntax. Also, what I was thinking was that the pipe character would only be there if there were parameters, otherwise no pipes.</P>


	<P>I’ve never played with  YACC  although I would like to. Maybe  RACC  would be a fun place to start.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>tt</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>14 Oct 2005</NOBR> at <NOBR>12:01</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Parsers can also be written in OCaml (cf. cil.sf.net or nekovm.org).</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Deirdre</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>14 Oct 2005</NOBR> at <NOBR>16:12</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>“Drop-kick me Jesus through the goalposts of life, end over end through them righteous uprights.”</P>


	<P>I envy anyone with serious  YACC -fu, but I am not among them.</P>


	<P>I’m with JB. I like the current syntax. Of the alternates, I dislike them nearly equally, but have a slight preference for the arrow and the colon (in that order).</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>meig</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>15 Oct 2005</NOBR> at <NOBR>03:41</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>How about adding a colon to the last pipe symbol? lineofcode = ‘a.each {|c=(b|d)|: puts c}’; puts m = (/(?:[ |\{])(\|.*?\|:)/).match(lineofcode)</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>joesb</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>15 Oct 2005</NOBR> at <NOBR>09:16</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>It’s pity that, while the groups of developer can solve all the problem in implementing Ruby, e.g., Thread, Continuation, Porting ruby to many platform , uses of  YAML ; we just can’t get the syntax we want simply because Yacc doesn’t allow it.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>kim</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>15 Oct 2005</NOBR> at <NOBR>11:31</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>If someone wants to check out a LexerInRuby go to www.rubygarden.org/ruby?RubyOnlineCookbook. Another text scanning tool is www.rubyhacker.com/code/scanf/ (a C tool which may be optimized by cil.sf.net).</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>sporkmonger</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>15 Oct 2005</NOBR> at <NOBR>22:17</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Incidentally, jvoorhis, Groovy used to have just the single goalpost before they discovered the bitwise-or problem.  Identical syntax to what you were just saying.</P>


	<P>Curious, how would Matz’s current syntax plan look with do..end blocks?</P>


<PRE>1.times -&gt; (foo="bar") do
  puts foo
end
</PRE>

	<P>If so, that just made me hate the idea even more I think.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>meig</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>16 Oct 2005</NOBR> at <NOBR>03:20</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Another option to get the parser reach the last pipe symbol would be to add a colon to bitwise-or: ”|:”  (instead of adding a colon to the last pipe symbol). Each of the two enclosing ”|” must then be followed by a [^:] in the regexp.</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>lisp_guy</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>16 Oct 2005</NOBR> at <NOBR>16:55</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>John McCarthy figured out the solution back in 1958: get rid of syntax completely.</P>


	<P>Lisp forever!</P></DIV></DIV>
</DIV>

<DIV class="entry">
    <DIV class="entryAttrib">
        <DIV class="entryAuthor"><H3>Ben</H3></DIV>
        <DIV class="entryTime">said on 
    <NOBR>30 Jan 2006</NOBR> at <NOBR>04:29</NOBR>
    <NOSCRIPT></NOSCRIPT>
  </DIV>
    </DIV>
    <DIV class="entryContentOuter"><DIV class="entryContent"><P>Isn’t there a formal  BNF  for Ruby anywhere?
If so, then switching to ANTLER  shouldn’t be too difficult.</P>


	<P>If not, then I suggest making one before starting to hack like this. I think this problem can be solved by making a  BNF : (note: I don;t know  BNF  very well so this is probably not correct!!)</P>


<PRE>block_decl := 
     '{' '|' block_var_decl '|' block_code '}'
block_var_decl :=
     EMPTY
     var_assignment
     var_assignment ',' block_var_decl
var_assignment := 
     var_decl "=" expression 
expression := 
     decl
     '(' decl '|' more_decl ')'
</PRE>
Hopefully this is valid…

	<P>I think the problem with the ’-&gt;’ vs ’:’ vs ’.’ syntaxes is they don’t give you any context about what they are supposed to do. Why not use proc or function or def instead?</P>


	<P>Cheers,
Ben</P></DIV></DIV>
</DIV>


  <DIV class="entry">
    <P><SMALL>Comments are closed for this entry.</SMALL></P>
  



        </DIV> 

</DIV>



</DIV>





</DIV></BODY></HTML>